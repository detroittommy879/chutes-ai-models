when i tried to run this on docker in a container on my server, which i have done before, now it immediately says failed all tests even with 10, isntant lists all of them as failed. something must have changed between last time i made a server

bigtokens\requirements.txt:
<code>
# Requirements for Token Generator
tiktoken>=0.5.0
pathlib>=1.0.1
</code>

bigtokens\simple_token_generator.py:
<code>
#!/usr/bin/env python3
"""
Simple Token Generator for Chutes.ai API Testing
=================================================

Generates plain text files with controlled token counts for testing 
the actual token limits of Chutes.ai models.

Unlike token_generator.py, this is focused on simplicity and speed:
- No complex text processing
- Just generates content with predictable token counts
- Perfect for API testing (what matters is the file size, not content quality)

Usage:
    python simple_token_generator.py 8000           # Generate 8k tokens
    python simple_token_generator.py 32000          # Generate 32k tokens
    python simple_token_generator.py 8000 16000 32k # Multiple files
    python simple_token_generator.py --list          # Show common test sizes
"""

import sys
import argparse
from pathlib import Path
from typing import List

try:
    import tiktoken
    TIKTOKEN_AVAILABLE = True
except ImportError:
    TIKTOKEN_AVAILABLE = False
    print("‚ö†Ô∏è  Warning: tiktoken not installed. Install with: pip install tiktoken")
    print("   Using approximate method (4 chars ‚âà 1 token)\n")


class SimpleTokenGenerator:
    """Lightweight token file generator focused on simplicity."""

    def __init__(self, model: str = 'openai', verbose: bool = False):
        """
        Initialize generator.
        
        Args:
            model: Token model ('openai', 'claude', 'approximate')
            verbose: Print detailed info
        """
        self.model = model
        self.verbose = verbose
        self.output_dir = Path('generated_tokens')
        self.output_dir.mkdir(exist_ok=True)

        # Set up token counter
        if model == 'openai' and TIKTOKEN_AVAILABLE:
            try:
                self.encoder = tiktoken.get_encoding('cl100k_base')
                self.use_tiktoken = True
                if self.verbose:
                    print(f"‚úì Using tiktoken (OpenAI cl100k_base encoding)")
            except Exception as e:
                print(f"Warning: Failed to load tiktoken: {e}")
                self.use_tiktoken = False
        else:
            self.use_tiktoken = False
            if self.verbose:
                print(f"‚úì Using approximate method (4 chars ‚âà 1 token)")

    def count_tokens(self, text: str) -> int:
        """Count tokens in text."""
        if self.use_tiktoken:
            try:
                return len(self.encoder.encode(text))
            except Exception:
                pass
        
        # Fallback: approximate (4 chars ‚âà 1 token)
        return max(1, len(text) // 4)

    def generate_file(self, target_tokens: int, filename: str = None) -> Path:
        """
        Generate a text file with approximately target_tokens tokens.
        
        Args:
            target_tokens: Desired number of tokens
            filename: Optional custom filename
            
        Returns:
            Path to generated file
        """
        if filename is None:
            filename = f"tokens_{target_tokens:,}.txt"
        
        output_path = self.output_dir / filename

        # Simple content generation: repeat a base string
        # Each word is ~1 token, and words are separated by spaces
        base_text = self._generate_base_text()
        
        # Estimate how much we need
        words_needed = int(target_tokens * 1.1)  # Add 10% buffer
        
        # Build content
        content = (base_text + " ") * (words_needed // len(base_text.split())) 
        
        # Fine-tune to exact token count
        current_tokens = self.count_tokens(content)
        
        while current_tokens < target_tokens:
            content += base_text + " "
            current_tokens = self.count_tokens(content)
        
        # Trim excess
        while current_tokens > target_tokens + 50:  # Allow 50 token variance
            lines = content.split('\n')
            if len(lines) > 1:
                content = '\n'.join(lines[:-1])
            else:
                # Remove words from end
                words = content.split()
                if len(words) > 1:
                    content = ' '.join(words[:-10])
                else:
                    break
            current_tokens = self.count_tokens(content)

        # Write file
        output_path.write_text(content, encoding='utf-8')
        final_tokens = self.count_tokens(content)

        # Info
        size_kb = output_path.stat().st_size / 1024
        print(f"‚úì {output_path.name}")
        print(f"  ‚îî‚îÄ Target: {target_tokens:,} tokens | Actual: {final_tokens:,} tokens | File: {size_kb:.1f} KB")

        return output_path

    @staticmethod
    def _generate_base_text() -> str:
        """Return base text for content generation."""
        return """
The quick brown fox jumps over the lazy dog. This is a test sentence for generating 
content with controlled token counts. The purpose of this text is to create files that 
can be used to test the actual input token limits of various AI models on the Chutes.ai 
platform. By generating files of specific token sizes we can empirically determine whether 
the published token limits are accurate. This is important for verifying that a model which 
claims to handle 32k tokens actually does handle that amount without truncation or errors. 
The content itself doesn't matter, only the token count matters for this testing purpose. 
Each repetition adds more tokens to reach the target size. The generation algorithm ensures 
that the final file contains approximately the requested number of tokens. This allows us to 
create test cases for different claimed token limits and see which ones are accurate and which 
ones are overstated in the documentation. Testing is key to understanding the real capabilities 
of these models.
""".strip()


def parse_size(size_str: str) -> int:
    """Parse size string like '32k', '128k', '1m' to integer."""
    size_str = size_str.strip().lower()
    
    if size_str.endswith('k'):
        return int(size_str[:-1]) * 1000
    elif size_str.endswith('m'):
        return int(size_str[:-1]) * 1000000
    else:
        return int(size_str)


def main():
    parser = argparse.ArgumentParser(
        description='Generate text files with controlled token counts for API testing'
    )
    parser.add_argument(
        'sizes',
        nargs='*',
        help='Token sizes to generate (e.g., 8000, 32k, 128k). Omit to show common sizes.'
    )
    parser.add_argument(
        '--model',
        default='openai',
        choices=['openai', 'claude', 'approximate'],
        help='Token counting model (default: openai)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output'
    )
    parser.add_argument(
        '--list',
        action='store_true',
        help='Show common test sizes'
    )

    args = parser.parse_args()

    if args.list or (not args.sizes and not sys.stdin.isatty()):
        print("Common token sizes for testing:")
        print()
        sizes = [
            (2000, "Small/minimum test"),
            (4000, "Short context"),
            (8000, "Standard 8k limit"),
            (16000, "Extended context"),
            (32000, "32k limit"),
            (64000, "64k limit (GPT-4 Turbo)"),
            (128000, "128k limit (GPT-4)"),
        ]
        for size, desc in sizes:
            print(f"  {size:>6,} tokens  - {desc}")
        print()
        print("Usage:")
        print("  python simple_token_generator.py 8000 32000 64000")
        print("  python simple_token_generator.py 32k 128k")
        return 0

    if not args.sizes:
        parser.print_help()
        return 0

    print(f"Generating token files ({args.model} tokenizer)...\n")

    generator = SimpleTokenGenerator(model=args.model, verbose=args.verbose)

    for size_str in args.sizes:
        try:
            tokens = parse_size(size_str)
            generator.generate_file(tokens)
        except ValueError:
            print(f"‚úó Invalid size: {size_str}")
            return 1

    print(f"\n‚úì Files saved to: {generator.output_dir.absolute()}")
    return 0


if __name__ == '__main__':
    sys.exit(main())

</code>

public\index.html:
<code>
<!doctype html>
<html lang="en">
    <head>
        <!-- Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-V8B90DGEJV"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'G-V8B90DGEJV');
        </script>

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        
        <!-- Primary Meta Tags -->
        <title>Chutes AI Model Explorer - Enhanced | Browse All AI Models</title>
        <meta name="title" content="Chutes AI Model Explorer - Enhanced | Browse All AI Models" />
        <meta name="description" content="Explore and compare ALL AI models including text, image, video, and audio generation. View pricing, performance metrics, and real-time availability for VLLM, ComfyUI, TGI, and custom models." />
        <meta name="keywords" content="AI models, Chutes AI, VLLM, ComfyUI, TGI, AI model explorer, AI pricing, text generation, image generation, video generation, audio AI, machine learning models, LLM comparison" />
        <meta name="author" content="wuu73.org" />
        <meta name="robots" content="index, follow" />
        <link rel="canonical" href="https://wuu73.org/chutes-models-enhanced/" />

        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://wuu73.org/chutes-models-enhanced/" />
        <meta property="og:title" content="Chutes AI Model Explorer - Enhanced | Browse All AI Models" />
        <meta property="og:description" content="Explore and compare ALL AI models including text, image, video, and audio generation. View pricing, performance metrics, and real-time availability." />
        <meta property="og:image" content="https://wuu73.org/chutes-models-enhanced/og-image.png" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="630" />
        <meta property="og:site_name" content="Chutes AI Model Explorer" />
        <meta property="og:locale" content="en_US" />

        <!-- Twitter Card -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:url" content="https://wuu73.org/chutes-models-enhanced/" />
        <meta name="twitter:title" content="Chutes AI Model Explorer - Enhanced | Browse All AI Models" />
        <meta name="twitter:description" content="Explore and compare ALL AI models including text, image, video, and audio generation. View pricing, performance metrics, and real-time availability." />
        <meta name="twitter:image" content="https://wuu73.org/chutes-models-enhanced/og-image.png" />
        <meta name="twitter:creator" content="@wuu73" />

        <!-- Additional SEO Meta Tags -->
        <meta name="theme-color" content="#060b16" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="format-detection" content="telephone=no" />

        <!-- Favicon (add your favicon files) -->
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />

        <!-- Fonts -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Sansation:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
            rel="stylesheet"
        />
        
        <!-- Stylesheet -->
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <div class="container">
            <header>
                <div class="header-bar">
                    <h1>Chutes AI Model Explorer <span class="badge-enhanced">Enhanced</span></h1>
                    <div class="header-actions">
                        <label class="theme-selector-label" for="themeSelector">Theme</label>
                        <select id="themeSelector" class="theme-selector">
                            <option value="light-default">Light - Default</option>
                            <option value="light-warm">Light - Warm</option>
                            <option value="dark-default" selected>Dark - Default</option>
                            <option value="dark-vibrant">Dark - Vibrant</option>
                            <option value="dark-midnight">Dark - Midnight</option>
                        </select>
                    </div>
                </div>
                <p>Browse ALL AI models including text, image, video, and audio generation</p>

                <div class="controls">
                    <div class="control-group">
                        <label class="control-label" for="templateFilter">Template</label>
                        <select id="templateFilter" class="control-input">
                            <option value="">All Templates</option>
                            <option value="vllm">VLLM (Text)</option>
                            <option value="comfyui">ComfyUI (Image/Video)</option>
                            <option value="tgi">TGI (Text)</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="nameSearch">Search Name</label>
                        <input type="text" id="nameSearch" class="control-input" placeholder="Search by name..." />
                    </div>

                    <div class="control-group">
                        <label class="control-label" for="limitSelect">Show</label>
                        <select id="limitSelect" class="control-input">
                            <option value="25">25 models</option>
                            <option value="50">50 models</option>
                            <option value="100">100 models</option>
                            <option value="200">200 models</option>
                            <option value="1000" selected>All models</option>
                        </select>
                    </div>

                    <button id="updateBtn" class="action-button">Update Models</button>

                    <div class="control-spacer" aria-hidden="true"></div>

                    <button id="downloadCsvBtn" class="ghost-button" type="button">Download CSV</button>
                    <button id="downloadMdBtn" class="ghost-button" type="button">Download Markdown</button>
                </div>

                <!-- Latency Testing Section -->
                <div class="latency-tester" id="latencyTester" style="display: none;">
                    <h2 style="margin-top: 2rem; margin-bottom: 1rem; color: var(--color-text);">üöÄ Model Latency Tester</h2>
                    <div class="test-controls" style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 300px;">
                            <label for="testPrompt" style="display: block; margin-bottom: 0.5rem; color: var(--color-text);">Test Prompt:</label>
                            <textarea 
                                id="testPrompt" 
                                rows="3" 
                                style="width: 100%; padding: 0.5rem; background: var(--color-surface); color: var(--color-text); border: 1px solid var(--color-border); border-radius: 4px; font-family: inherit;"
                                placeholder="Enter a test prompt...">Write a haiku about programming.</textarea>
                        </div>
                        <div style="flex: 0; min-width: 200px; display: flex; flex-direction: column; justify-content: flex-end; gap: 0.5rem;">
                            <button id="selectAllTestBtn" class="action-button" style="width: 100%;">Select All Visible</button>
                            <button id="selectTop10Btn" class="action-button" style="width: 100%;">Select Top 10</button>
                            <button id="clearSelectionBtn" class="ghost-button" style="width: 100%;">Clear Selection</button>
                            <button id="runLatencyTestBtn" class="action-button" style="width: 100%;" disabled>Run Test (0 selected)</button>
                            <button id="runTokenTestBtn" class="action-button" style="width: 100%; background: var(--color-accent); border-color: var(--color-accent);" disabled>Run Token Test (0 selected)</button>
                        </div>
                    </div>
                    <div id="latencyResults" style="margin-top: 1rem;"></div>
                </div>
            </header>

            <main>
                <div id="loading" class="loading">
                    <div class="spinner"></div>
                    <p>Loading complete model information...</p>
                </div>

                <div id="error" class="error hidden">
                    <p>Failed to load model information. Please check server logs.</p>
                </div>

                <div id="stats" class="stats hidden">
                    <div class="stat-item">
                        <span class="stat-label">Total Models:</span>
                        <span class="stat-value" id="totalModels">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Showing:</span>
                        <span class="stat-value" id="showingModels">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Page:</span>
                        <span class="stat-value" id="currentPage">1</span>
                    </div>
                    <div class="stat-item cache-status" id="cacheStatus">
                        <span class="stat-label">Cache:</span>
                        <span class="stat-value" id="cacheInfo">Loading...</span>
                    </div>
                </div>

                <div class="resource-links hidden" id="resourceLinks">
                    <a href="https://wuu73.org/blog/" target="_blank" rel="noopener noreferrer" class="resource-link">
                       
                        <span class="link-text">Lots of cool AI stuff and links</span>
                        <span class="link-arrow">‚Üí</span>
                    </a>
                    <a href="https://wuu73.org/aicp" target="_blank" rel="noopener noreferrer" class="resource-link">
                        <span class="link-icon">üîß</span>
                        <span class="link-text">Free Local AI Surgical Context Automater</span>
                        <span class="link-arrow">‚Üí</span>
                    </a>
                    <div class="donation-accordion">
                        <button
                            class="resource-link donation-toggle"
                            type="button"
                            aria-expanded="false"
                            aria-controls="donationDetails"
                        >
                            <span class="donation-icon" aria-hidden="true">üíö</span>
                            <span class="donation-mainline">
                                <span class="donation-title"><p>Support with TAO</p></span>
                                 <div style="height:1em"></div>
                                   <span class="donation-address"><p>5Hq3foT3rBKfDB2Py8jVrDvg3yPUeFEdWqwwKKnih5fqCS9X</p></span>
                                <div style="height:1em"></div>
                                <span class="donation-highlight">We only need <strong>0.0307 TAO</strong> per month for reliability testing (~$12 USD).</span>
                                <span class="donation-footnote">Sponsors are highlighted here for the month. Email <span class="donation-contact"><a href="mailto:tom@wuu73.org">tom@wuu73.org</a></span> with questions or ideas.</span>
                            </span>
                            <span class="accordion-arrow" aria-hidden="true">‚Üì</span>
                        </button>
                        <div class="donation-content" id="donationDetails" hidden>
                            <div class="donation-details">
                                <p><strong>Why donate?</strong> Your support funds deeper testing for uptime, latency, token limits, and reliability across every model.</p>
                                <ul class="donation-list">
                                    <li>Share verified uptime and delay data for any model, any day.</li>
                                    <li>Identify reliable, low-cost providers for coding, image, or video workloads.</li>
                                    <li>Confirm JSON/tooling/XML capabilities for agentic tasks.</li>
                                    <li>Expand periodic testing so you get fail rates, speed, and availability updates.</li>
                                </ul>
                                <p>If you contribute TAO or other crypto (BTC, LTC, etc.) we invest it directly into more testing and better guidance. After donating, drop a note to <a href="mailto:tom@wuu73.org">tom@wuu73.org</a> so we can connect it.</p>
                                <div class="donation-addresses">
                                    <div><strong>BTC:</strong> <span class="crypto-address">bc1qne2mffgcjwk4f5lnffs6gcmu63rwskl3yadtkp</span></div>
                                    <div><strong>LTC:</strong> <span class="crypto-address">ltc1q3z327a3ea22mlhtawmdjxmwn69n65a32fek2s4</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="modelsContainer" class="models-container hidden">
                    <!-- Models will be dynamically inserted here -->
                </div>

                <div id="pagination" class="pagination hidden">
                    <button id="prevBtn" class="page-btn">‚Üê Previous</button>
                    <span id="pageInfo"></span>
                    <button id="nextBtn" class="page-btn">Next ‚Üí</button>
                </div>
            </main>
        </div>

        <script type="module" src="script.js"></script>
    </body>
</html>

</code>

public\script.js:
<code>
document.addEventListener('DOMContentLoaded', function() {
    const updateBtn = document.getElementById('updateBtn');
    const loading = document.getElementById('loading');
    const error = document.getElementById('error');
    const modelsContainer = document.getElementById('modelsContainer');
    const stats = document.getElementById('stats');
    const pagination = document.getElementById('pagination');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfo = document.getElementById('pageInfo');

    // Filter controls
    const templateFilter = document.getElementById('templateFilter');
    const nameSearch = document.getElementById('nameSearch');
    const limitSelect = document.getElementById('limitSelect');

    // Theme and download controls
    const themeSelector = document.getElementById('themeSelector');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const downloadMdBtn = document.getElementById('downloadMdBtn');

    // State
    let currentSort = { column: null, direction: 'asc' };
    let allModels = [];
    let fullModelsList = []; // Store all models from server for client-side filtering
    let filteredModels = []; // Store filtered results
    let currentPage = 0;
    let totalModels = 0;
    let limit = 1000; // Default to all models
    let v1ModelsMap = new Map(); // Map of model IDs to v1 model data (for modalities)

    // API endpoint (our local server) - auto-detect base path
    const BASE_PATH = window.location.pathname.match(/^\/[^\/]+\//)?.[0] || '/';
    const API_URL = `${BASE_PATH}api/models`.replace(/\/+/g, '/');

    // Initialize theme
    initializeTheme();

    // Theme management
    function initializeTheme() {
        // Check for stored preference first
        const storedTheme = localStorage.getItem('theme');
        
        let theme;
        if (storedTheme) {
            theme = storedTheme;
        } else {
            // Check OS preference
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            // Default to dark-default if no preference detected or if dark is preferred
            theme = prefersDark ? 'dark-default' : 'dark-default';
        }
        
        setTheme(theme);
    }

    function setTheme(theme) {
        document.body.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        themeSelector.value = theme;
    }

    function handleThemeChange(event) {
        const selectedTheme = event.target.value;
        setTheme(selectedTheme);
    }

    // Download functions
    function downloadCSV() {
        const sortedModels = sortModelsData(allModels, currentSort.column, currentSort.direction);
        
        // CSV header
        const headers = ['Model Name', 'Template', 'Input Modality', 'Output Modality', 'Input Price ($/M)', 'Output Price ($/M)', 'Invocations', 'Status', 'Hot', 'Chutes AI Link'];
        const csvRows = [headers.join(',')];
        
        // CSV rows
        sortedModels.forEach(model => {
            const name = (model.name || 'Unknown').replace(/"/g, '""');
            const template = model.standard_template || 'custom';
            const v1Model = v1ModelsMap.get(model.name);
            const inputModality = v1Model?.input_modalities?.join(';') || 'text';
            const outputModality = v1Model?.output_modalities?.join(';') || 'text';
            const inputPrice = model.current_estimated_price?.per_million_tokens?.input?.usd || 0;
            const outputPrice = model.current_estimated_price?.per_million_tokens?.output?.usd || 0;
            const invocations = model.invocation_count || 0;
            const hasActiveInstance = (model.instances || []).some(inst => inst.active && inst.verified);
            const status = hasActiveInstance ? 'Active' : 'Inactive';
            const hot = model.hot ? 'Yes' : 'No';
            const chuteId = model.chute_id || '';
            const link = chuteId ? `https://chutes.ai/app/chute/${chuteId}` : '';
            
            const row = [
                `"${name}"`,
                template,
                inputModality,
                outputModality,
                inputPrice.toFixed(3),
                outputPrice.toFixed(3),
                invocations,
                status,
                hot,
                link
            ];
            csvRows.push(row.join(','));
        });
        
        const csvContent = csvRows.join('\n');
        downloadFile(csvContent, 'chutes-models.csv', 'text/csv');
    }

    function downloadMarkdown() {
        const sortedModels = sortModelsData(allModels, currentSort.column, currentSort.direction);
        
        let mdContent = '# Chutes AI Models\n\n';
        mdContent += `*Generated on ${new Date().toLocaleDateString()}*\n\n`;
        mdContent += `**Total Models:** ${sortedModels.length}\n\n`;
        mdContent += '---\n\n';
        
        // Table header
        mdContent += '| Model Name | Template | Input ‚Üí Output | Input Price | Output Price | Invocations | Status | Hot |\n';
        mdContent += '|------------|----------|----------------|-------------|--------------|-------------|--------|-----|\n';
        
        // Table rows
        sortedModels.forEach(model => {
            const name = model.name || 'Unknown';
            const template = (model.standard_template || 'custom').toUpperCase();
            const v1Model = v1ModelsMap.get(model.name);
            const inputModality = v1Model?.input_modalities?.join(', ') || 'text';
            const outputModality = v1Model?.output_modalities?.join(', ') || 'text';
            const modality = `${inputModality} ‚Üí ${outputModality}`;
            const inputPrice = `$${(model.current_estimated_price?.per_million_tokens?.input?.usd || 0).toFixed(3)}`;
            const outputPrice = `$${(model.current_estimated_price?.per_million_tokens?.output?.usd || 0).toFixed(3)}`;
            const invocations = formatInvocations(model.invocation_count || 0);
            const hasActiveInstance = (model.instances || []).some(inst => inst.active && inst.verified);
            const status = hasActiveInstance ? '‚úÖ Active' : '‚ùå Inactive';
            const hot = model.hot ? 'üî• Hot' : 'Cold';
            const chuteId = model.chute_id || '';
            const modelLink = chuteId ? `[${name}](https://chutes.ai/app/chute/${chuteId})` : name;
            
            mdContent += `| ${modelLink} | ${template} | ${modality} | ${inputPrice} | ${outputPrice} | ${invocations} | ${status} | ${hot} |\n`;
        });
        
        mdContent += '\n---\n\n';
        mdContent += '*Powered by [Chutes AI](https://chutes.ai)*\n';
        
        downloadFile(mdContent, 'chutes-models.md', 'text/markdown');
    }

    function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    // Create colorful modality badges
    function createModalityBadgesHTML(inputs, outputs) {
        const inputBadges = inputs.map(m => `<span class="modality-badge ${getModalityClass(m)}">${m}</span>`).join(' ');
        const outputBadges = outputs.map(m => `<span class="modality-badge ${getModalityClass(m)}">${m}</span>`).join(' ');
        return `${inputBadges}<span class="modality-arrow">‚Üí</span>${outputBadges}`;
    }

    function getModalityClass(modality) {
        const mod = modality.toLowerCase();
        if (mod === 'text') return 'text';
        if (mod === 'image') return 'image';
        if (mod === 'audio') return 'audio';
        if (mod === 'video') return 'video';
        return 'other';
    }

    // Debounce function for search
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Fetch v1 models data (for modalities info)
    async function fetchV1Models() {
        try {
            const response = await fetch(`${BASE_PATH}api/models/v1/all`.replace(/\/+/g, '/'));
            if (response.ok) {
                const data = await response.json();
                if (data.data && Array.isArray(data.data)) {
                    data.data.forEach(model => {
                        v1ModelsMap.set(model.id, model);
                    });
                    console.log(`Loaded ${v1ModelsMap.size} models with modality info`);
                }
            }
        } catch (err) {
            console.warn('Could not fetch v1 models:', err);
        }
    }

    // Fetch models from our server
    async function fetchModels() {
        try {
            showLoading();
            
            const params = new URLSearchParams();
            params.append('page', 0);
            params.append('limit', 1000); // Fetch all models once
            params.append('include_public', 'true');
            params.append('include_schemas', 'true');
            
            // Only apply template filter to server request
            if (templateFilter.value) {
                params.append('template', templateFilter.value);
            }

            const response = await fetch(`${API_URL}?${params.toString()}`);

            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }

            // Get cache information from headers
            const cacheStatus = response.headers.get('X-Cache');
            const cacheAge = response.headers.get('X-Cache-Age');
            const cacheDate = response.headers.get('X-Cache-Date');
            console.log('Cache headers:', { cacheStatus, cacheAge, cacheDate });
            updateCacheStatus(cacheStatus, cacheAge, cacheDate);

            const data = await response.json();
            fullModelsList = data.items || [];
            
            // Apply client-side filters
            applyFilters();
            
            hideLoading();

        } catch (err) {
            console.error('Error fetching models:', err);
            showError();
            hideLoading();
        }
    }

    // Apply client-side filtering (search and pagination)
    function applyFilters() {
        // Start with full list
        let filtered = [...fullModelsList];
        
        // Apply name search filter (client-side)
        const searchTerm = nameSearch.value.trim().toLowerCase();
        if (searchTerm) {
            filtered = filtered.filter(model => {
                const modelName = (model.name || '').toLowerCase();
                return modelName.includes(searchTerm);
            });
        }
        
        filteredModels = filtered;
        totalModels = filtered.length;
        
        // Calculate pagination
        const startIndex = currentPage * limit;
        const endIndex = startIndex + limit;
        allModels = filtered.slice(startIndex, endIndex);
        
        // Display results
        displayModels({ items: allModels, total: totalModels });
        updateStats({ items: allModels, total: totalModels });
        updatePagination();
    }

    // Display models in the container
    function displayModels(data) {
        if (!data || !data.items || !Array.isArray(data.items)) {
            showError();
            return;
        }

        allModels = data.items;
        modelsContainer.innerHTML = '';

        // Create table header with sorting
        const tableHeader = document.createElement('div');
        tableHeader.className = 'table-header';
        tableHeader.innerHTML = `
            <div class="header-cell" data-column="name">
                <span>Model Name</span>
                <span class="sort-indicator ${currentSort.column === 'name' ? 'active' : ''}">${getSortIcon('name')}</span>
            </div>
            <div class="header-cell" data-column="template">
                <span>Template</span>
                <span class="sort-indicator ${currentSort.column === 'template' ? 'active' : ''}">${getSortIcon('template')}</span>
            </div>
            <div class="header-cell" data-column="input_modalities">
                <span>Input Modalities</span>
                <span class="sort-indicator ${currentSort.column === 'input_modalities' ? 'active' : ''}">${getSortIcon('input_modalities')}</span>
            </div>
            <div class="header-cell" data-column="output_modalities">
                <span>Output Modalities</span>
                <span class="sort-indicator ${currentSort.column === 'output_modalities' ? 'active' : ''}">${getSortIcon('output_modalities')}</span>
            </div>
            <div class="header-cell" data-column="input_context">
                <span>Input Ctx</span>
                <span class="sort-indicator ${currentSort.column === 'input_context' ? 'active' : ''}">${getSortIcon('input_context')}</span>
            </div>
            <div class="header-cell" data-column="output_context">
                <span>Output Ctx</span>
                <span class="sort-indicator ${currentSort.column === 'output_context' ? 'active' : ''}">${getSortIcon('output_context')}</span>
            </div>
            <div class="header-cell" data-column="visibility">
                <span>Visibility</span>
                <span class="sort-indicator ${currentSort.column === 'visibility' ? 'active' : ''}">${getSortIcon('visibility')}</span>
            </div>
            <div class="header-cell" data-column="sampling">
                <span>Features</span>
                <span class="sort-indicator ${currentSort.column === 'sampling' ? 'active' : ''}">${getSortIcon('sampling')}</span>
            </div>
            <div class="header-cell" data-column="quantization">
                <span>Quant</span>
                <span class="sort-indicator ${currentSort.column === 'quantization' ? 'active' : ''}">${getSortIcon('quantization')}</span>
            </div>
            <div class="header-cell" data-column="created">
                <span>Created</span>
                <span class="sort-indicator ${currentSort.column === 'created' ? 'active' : ''}">${getSortIcon('created')}</span>
            </div>
            <div class="header-cell" data-column="inputPrice">
                <span>Input Price</span>
                <span class="sort-indicator ${currentSort.column === 'inputPrice' ? 'active' : ''}">${getSortIcon('inputPrice')}</span>
            </div>
            <div class="header-cell" data-column="outputPrice">
                <span>Output Price</span>
                <span class="sort-indicator ${currentSort.column === 'outputPrice' ? 'active' : ''}">${getSortIcon('outputPrice')}</span>
            </div>
            <div class="header-cell" data-column="invocations">
                <span>Invocations</span>
                <span class="sort-indicator ${currentSort.column === 'invocations' ? 'active' : ''}">${getSortIcon('invocations')}</span>
            </div>
            <div class="header-cell" data-column="status">
                <span>Status</span>
                <span class="sort-indicator ${currentSort.column === 'status' ? 'active' : ''}">${getSortIcon('status')}</span>
            </div>
            <div class="header-cell" data-column="hot">
                <span>Hot</span>
                <span class="sort-indicator ${currentSort.column === 'hot' ? 'active' : ''}">${getSortIcon('hot')}</span>
            </div>
        `;
        modelsContainer.appendChild(tableHeader);

        // Add click listeners for sorting
        tableHeader.querySelectorAll('.header-cell').forEach(cell => {
            cell.addEventListener('click', function() {
                const column = this.dataset.column;
                sortModels(column);
            });
        });

        // Apply current sort and display model rows
        const sortedModels = sortModelsData(allModels, currentSort.column, currentSort.direction);
        sortedModels.forEach((model, index) => {
            const modelRow = createModelRow(model, index);
            modelsContainer.appendChild(modelRow);
        });

        modelsContainer.classList.remove('hidden');
        
        // Add latency testing checkboxes and show tester
        addTestCheckboxes();
        showLatencyTester();
    }

    // Create a model row element
    function createModelRow(model, index) {
        const row = document.createElement('div');
        row.className = 'model-row';

        const name = model.name || 'Unknown';
        const chuteId = model.chute_id || '';
        const modelUrl = chuteId ? `https://chutes.ai/app/chute/${chuteId}` : '#';
        const template = model.standard_template || 'custom';
        const inputPrice = model.current_estimated_price?.per_million_tokens?.input?.usd || 0;
        const outputPrice = model.current_estimated_price?.per_million_tokens?.output?.usd || 0;
        const invocations = model.invocation_count || 0;
        const gpus = model.supported_gpus || [];
        const instances = model.instances || [];
        const isHot = model.hot || false;

        // Try to get modality info from v1 models
        const v1Model = v1ModelsMap.get(model.name);
        let inputModalities = v1Model?.input_modalities || [];
        let outputModalities = v1Model?.output_modalities || [];
        const supportedFeatures = v1Model?.supported_features || [];
    const inputContext = v1Model?.context_length || null;
    const outputContext = v1Model?.max_output_length || null;
        const quantization = v1Model?.quantization || null;
        const createdDate = v1Model?.created ? new Date(v1Model.created * 1000).toLocaleDateString() : null;
        
        // Infer from template if not available
        if (inputModalities.length === 0 && outputModalities.length === 0) {
            if (template === 'vllm' || template === 'tgi') {
                inputModalities = ['text'];
                outputModalities = ['text'];
            } else if (template === 'comfyui') {
                inputModalities = ['text', 'image'];
                outputModalities = ['image', 'video'];
            } else {
                inputModalities = ['text'];
                outputModalities = ['text'];
            }
        }
        
    // Create modality badges HTML
    const modalityDisplay = createModalityBadgesHTML(inputModalities, outputModalities);

        // Check if any instance is active
        const hasActiveInstance = instances.some(inst => inst.active && inst.verified);
        const statusText = hasActiveInstance ? 'Active' : 'Inactive';
        const statusClass = hasActiveInstance ? 'active' : 'inactive';

        // Create GPU collapse button
        const gpuId = `gpu-${index}`;
        const gpuCount = gpus.length;
        const gpuDisplay = gpuCount > 0 
            ? `<button class="gpu-toggle" onclick="toggleGpu('${gpuId}')">${gpuCount} GPU${gpuCount !== 1 ? 's' : ''} ‚ñº</button>
               <div id="${gpuId}" class="gpu-details hidden">
                   ${gpus.map(gpu => `<span class="gpu-tag">${gpu.toUpperCase()}</span>`).join('')}
               </div>`
            : '<span style="color: #999;">N/A</span>';

        row.innerHTML = `
            <div class="model-cell model-name" title="${escapeHtml(name)}">
                ${chuteId ? `<a href="${modelUrl}" target="_blank" rel="noopener noreferrer" class="model-link">${escapeHtml(name)}</a>` : escapeHtml(name)}
            </div>
            <div class="model-cell template">
                <span class="template-badge ${template}">${template.toUpperCase()}</span>
            </div>
            <div class="model-cell input-modalities">
                <small>${inputModalities.length ? inputModalities.map(m => `<span class="modality-badge ${getModalityClass(m)}">${m}</span>`).join(' ') : '<span style="color: #999;">N/A</span>'}</small>
            </div>
            <div class="model-cell output-modalities">
                <small>${outputModalities.length ? outputModalities.map(m => `<span class="modality-badge ${getModalityClass(m)}">${m}</span>`).join(' ') : '<span style="color: #999;">N/A</span>'}</small>
            </div>
            <div class="model-cell input-context" title="${inputContext !== null ? formatNumber(inputContext) : 'N/A'}">
                ${getVerificationBadge(name, inputContext)}
                ${inputContext !== null ? `<span>${formatNumber(inputContext)}</span>` : '<span style="color: #999;">N/A</span>'}
            </div>
            <div class="model-cell output-context" title="${outputContext !== null ? formatNumber(outputContext) : 'N/A'}">
                ${outputContext !== null ? `<span>${formatNumber(outputContext)}</span>` : '<span style="color: #999;">N/A</span>'}
            </div>
            <div class="model-cell visibility">
                <span>${model.public === true ? 'Public' : (model.public === false ? 'Private' : 'Unknown')}</span>
            </div>
            <div class="model-cell features">
                ${supportedFeatures.length > 0 ? `<div class="features-mini">${supportedFeatures.map(f => `<span class="feature-mini">${formatFeatureName(f)}</span>`).join('')}</div>` : ''}
                ${Array.isArray(v1Model?.supported_sampling_parameters) ? `<span class="sampling-badge" title="${v1Model.supported_sampling_parameters.join(', ')}">${v1Model.supported_sampling_parameters.length} Sampling Params</span>` : ''}
            </div>
            <div class="model-cell quantization" title="${quantization || 'N/A'}">
                ${quantization ? `<span class="quant-badge">${escapeHtml(quantization)}</span>` : '<span style="color: #999;">N/A</span>'}
            </div>
            <div class="model-cell created" title="${createdDate || 'N/A'}">
                ${createdDate || '<span style="color: #999;">N/A</span>'}
            </div>
            <div class="model-cell price" title="$${inputPrice.toFixed(3)}/M tokens">$${inputPrice.toFixed(3)}</div>
            <div class="model-cell price" title="$${outputPrice.toFixed(3)}/M tokens">$${outputPrice.toFixed(3)}</div>
            <div class="model-cell invocations" title="${invocations.toLocaleString()} invocations">${formatInvocations(invocations)}</div>
            <div class="model-cell">
                <div class="status-indicator">
                    <span class="status-dot ${statusClass}"></span>
                    <span>${statusText}</span>
                </div>
            </div>
            <div class="model-cell">
                ${isHot ? '<div class="status-indicator"><span class="status-dot hot"></span><span>Hot</span></div>' : '<span style="color: #999;">Cold</span>'}
            </div>
        `;

        return row;
    }

    // Toggle GPU details
    window.toggleGpu = function(id) {
        const element = document.getElementById(id);
        const button = element.previousElementSibling;
        if (element.classList.contains('hidden')) {
            element.classList.remove('hidden');
            button.textContent = button.textContent.replace('‚ñº', '‚ñ≤');
        } else {
            element.classList.add('hidden');
            button.textContent = button.textContent.replace('‚ñ≤', '‚ñº');
        }
    };

    // Sorting functions
    function getSortIcon(column) {
        if (currentSort.column !== column) return '‚Üï';
        return currentSort.direction === 'asc' ? '‚Üë' : '‚Üì';
    }

    function sortModels(column) {
        if (currentSort.column === column) {
            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            currentSort.column = column;
            currentSort.direction = 'asc';
        }
        displayModels({ items: allModels });
    }

    function sortModelsData(models, column, direction) {
        if (!column) return models;

        const sorted = [...models].sort((a, b) => {
            let aVal, bVal;

            switch (column) {
                case 'name':
                    aVal = a.name || '';
                    bVal = b.name || '';
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);

                case 'template':
                    aVal = a.standard_template || '';
                    bVal = b.standard_template || '';
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);

                case 'inputPrice':
                    aVal = a.current_estimated_price?.per_million_tokens?.input?.usd || 0;
                    bVal = b.current_estimated_price?.per_million_tokens?.input?.usd || 0;
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                case 'outputPrice':
                    aVal = a.current_estimated_price?.per_million_tokens?.output?.usd || 0;
                    bVal = b.current_estimated_price?.per_million_tokens?.output?.usd || 0;
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                case 'invocations':
                    aVal = a.invocation_count || 0;
                    bVal = b.invocation_count || 0;
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                case 'modalities':
                    const getModalityString = (model) => {
                        const v1Model = v1ModelsMap.get(model.name);
                        if (v1Model) {
                            return `${(v1Model.input_modalities || []).join(',')}‚Üí${(v1Model.output_modalities || []).join(',')}`;
                        }
                        return model.standard_template || '';
                    };
                    aVal = getModalityString(a);
                    bVal = getModalityString(b);
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);

                case 'context':
                    const getContext = (model) => {
                        const v1Model = v1ModelsMap.get(model.name);
                        // Sort by input context, then output context if input is equal
                        const input = v1Model?.context_length || 0;
                        const output = v1Model?.max_output_length || 0;
                        return { input, output };
                    };
                    aVal = getContext(a);
                    bVal = getContext(b);
                    if (aVal.input !== bVal.input) {
                        return direction === 'asc' ? aVal.input - bVal.input : bVal.input - aVal.input;
                    } else {
                        return direction === 'asc' ? aVal.output - bVal.output : bVal.output - aVal.output;
                    }

                case 'quantization':
                    const getQuant = (model) => {
                        const v1Model = v1ModelsMap.get(model.name);
                        return v1Model?.quantization || '';
                    };
                    aVal = getQuant(a);
                    bVal = getQuant(b);
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);

                case 'created':
                    const getCreated = (model) => {
                        const v1Model = v1ModelsMap.get(model.name);
                        return v1Model?.created || 0;
                    };
                    aVal = getCreated(a);
                    bVal = getCreated(b);
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                case 'status':
                    aVal = (a.instances || []).some(inst => inst.active && inst.verified) ? 1 : 0;
                    bVal = (b.instances || []).some(inst => inst.active && inst.verified) ? 1 : 0;
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                case 'hot':
                    aVal = a.hot ? 1 : 0;
                    bVal = b.hot ? 1 : 0;
                    return direction === 'asc' ? aVal - bVal : bVal - aVal;

                // New columns for enhanced sorting
                case 'input_modalities':
                    try {
                        const getInputModalities = (model) => {
                            const v1Model = v1ModelsMap.get(model.name);
                            return v1Model?.input_modalities?.join(',') || '';
                        };
                        aVal = getInputModalities(a);
                        bVal = getInputModalities(b);
                        return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } catch (err) {
                        console.error('Error sorting input_modalities:', err);
                        return 0;
                    }

                case 'output_modalities':
                    try {
                        const getOutputModalities = (model) => {
                            const v1Model = v1ModelsMap.get(model.name);
                            return v1Model?.output_modalities?.join(',') || '';
                        };
                        aVal = getOutputModalities(a);
                        bVal = getOutputModalities(b);
                        return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } catch (err) {
                        console.error('Error sorting output_modalities:', err);
                        return 0;
                    }

                case 'input_context':
                    try {
                        const getInputContext = (model) => {
                            const v1Model = v1ModelsMap.get(model.name);
                            return v1Model?.context_length ?? 0;
                        };
                        aVal = getInputContext(a);
                        bVal = getInputContext(b);
                        return direction === 'asc' ? aVal - bVal : bVal - aVal;
                    } catch (err) {
                        console.error('Error sorting input_context:', err);
                        return 0;
                    }

                case 'output_context':
                    try {
                        const getOutputContext = (model) => {
                            const v1Model = v1ModelsMap.get(model.name);
                            return v1Model?.max_output_length ?? 0;
                        };
                        aVal = getOutputContext(a);
                        bVal = getOutputContext(b);
                        return direction === 'asc' ? aVal - bVal : bVal - aVal;
                    } catch (err) {
                        console.error('Error sorting output_context:', err);
                        return 0;
                    }

                case 'visibility':
                    try {
                        const getVisibility = (model) => {
                            if (model.public === true) return 2;
                            if (model.public === false) return 1;
                            return 0; // Unknown
                        };
                        aVal = getVisibility(a);
                        bVal = getVisibility(b);
                        return direction === 'asc' ? aVal - bVal : bVal - aVal;
                    } catch (err) {
                        console.error('Error sorting visibility:', err);
                        return 0;
                    }

                case 'sampling':
                    try {
                        const getSamplingCount = (model) => {
                            const v1Model = v1ModelsMap.get(model.name);
                            return Array.isArray(v1Model?.supported_sampling_parameters) ? v1Model.supported_sampling_parameters.length : 0;
                        };
                        aVal = getSamplingCount(a);
                        bVal = getSamplingCount(b);
                        return direction === 'asc' ? aVal - bVal : bVal - aVal;
                    } catch (err) {
                        console.error('Error sorting sampling:', err);
                        return 0;
                    }

                default:
                    return 0;
            }
        });

        return sorted;
    }

    // Update cache status display
    function updateCacheStatus(cacheStatus, cacheAge, cacheDate) {
        const cacheStatusEl = document.getElementById('cacheStatus');
        const cacheInfoEl = document.getElementById('cacheInfo');
        
        if (cacheStatus === 'HIT') {
            cacheStatusEl.style.display = 'flex';
            
            // Format cache date with simple time
            let dateStr = '';
            if (cacheDate) {
                const date = new Date(cacheDate);
                const dateOnly = date.toLocaleDateString();
                const hours = date.getHours();
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hour12 = hours % 12 || 12;
                const simpleTime = `${hour12}${ampm}`;
                dateStr = `${dateOnly} ${simpleTime}`;
            } else {
                dateStr = 'Unknown date';
            }
            
            // Convert seconds to human readable
            const ageSeconds = parseInt(cacheAge) || 0;
            const ageMinutes = Math.floor(ageSeconds / 60);
            const ageHours = Math.floor(ageMinutes / 60);
            const ageDays = Math.floor(ageHours / 24);
            
            let ageStr = '';
            if (ageDays > 0) {
                ageStr = `${ageDays} day${ageDays !== 1 ? 's' : ''} old`;
            } else if (ageHours > 0) {
                ageStr = `${ageHours} hour${ageHours !== 1 ? 's' : ''} old`;
            } else if (ageMinutes > 0) {
                ageStr = `${ageMinutes} min old`;
            } else {
                ageStr = `${ageSeconds}s old`;
            }
            
            cacheInfoEl.innerHTML = `${dateStr}<br><small>(${ageStr})</small>`;
            cacheInfoEl.style.color = '#4caf50';
        } else if (cacheStatus === 'MISS') {
            cacheStatusEl.style.display = 'flex';
            cacheInfoEl.innerHTML = 'Fresh data';
            cacheInfoEl.style.color = '#ff9800';
        } else {
            // No cache status - probably loading
            cacheStatusEl.style.display = 'flex';
            cacheInfoEl.innerHTML = 'Loading...';
            cacheInfoEl.style.color = '#999';
        }
    }

    // Update statistics display
    function updateStats(data) {
        document.getElementById('totalModels').textContent = data.total || 0;
        document.getElementById('showingModels').textContent = data.items?.length || 0;
        document.getElementById('currentPage').textContent = (currentPage + 1);
        stats.classList.remove('hidden');
        document.getElementById('resourceLinks').classList.remove('hidden');
    }

    // Update pagination controls
    function updatePagination() {
        const totalPages = Math.ceil(totalModels / limit);
        prevBtn.disabled = currentPage === 0;
        nextBtn.disabled = currentPage >= totalPages - 1;
        pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
        pagination.classList.remove('hidden');
    }

    // Utility functions
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatNumber(num) {
        if (num === null || num === undefined || typeof num !== 'number') return 'N/A';
        return num.toLocaleString();
    }

    function formatInvocations(count) {
        if (count >= 1000000) {
            return (count / 1000000).toFixed(1) + 'M';
        } else if (count >= 1000) {
            return (count / 1000).toFixed(1) + 'K';
        }
        return count.toString();
    }

    function formatFeatureName(feature) {
        return feature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }

    // Generate verification badge for tested models
    function getVerificationBadge(modelName, inputContext) {
        const testResult = tokenTestResults[modelName];
        
        if (!testResult || testResult.status !== 'success') {
            return '';
        }

        const testDate = new Date(testResult.lastTested);
        const dateStr = testDate.toLocaleDateString();
        const timeStr = testDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        const tooltipText = `Verified: ${dateStr} ${timeStr}
Input: ${testResult.inputTokens || testResult.tokenCount || 'N/A'} tokens
File: ${testResult.tokenFile || 'N/A'}
Context: ${formatNumber(testResult.inputContext || inputContext)}`;

        return `<span class="verification-badge" title="${tooltipText}">‚úì Verified</span>`;
    }

    // UI state management
    function showLoading() {
        loading.classList.remove('hidden');
        error.classList.add('hidden');
        modelsContainer.classList.add('hidden');
        stats.classList.add('hidden');
        pagination.classList.add('hidden');
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
    }

    function hideLoading() {
        loading.classList.add('hidden');
        updateBtn.disabled = false;
        updateBtn.textContent = 'Update Models';
    }

    function showError() {
        error.classList.remove('hidden');
        modelsContainer.classList.add('hidden');
        stats.classList.add('hidden');
        pagination.classList.add('hidden');
    }

    // Event listeners
    updateBtn.addEventListener('click', () => {
        currentPage = 0;
        fetchModels();
    });

    prevBtn.addEventListener('click', () => {
        if (currentPage > 0) {
            currentPage--;
            applyFilters();
        }
    });

    nextBtn.addEventListener('click', () => {
        const totalPages = Math.ceil(totalModels / limit);
        if (currentPage < totalPages - 1) {
            currentPage++;
            applyFilters();
        }
    });

    templateFilter.addEventListener('change', () => {
        currentPage = 0;
        fetchModels(); // Re-fetch from server when template changes
    });

    limitSelect.addEventListener('change', () => {
        limit = parseInt(limitSelect.value);
        currentPage = 0;
        applyFilters();
    });

    const debouncedSearch = debounce(() => {
        currentPage = 0;
        applyFilters(); // Client-side filtering only
    }, 300);

    nameSearch.addEventListener('input', debouncedSearch);

    // Theme selector listener
    themeSelector.addEventListener('change', handleThemeChange);

    // Download button listeners
    downloadCsvBtn.addEventListener('click', downloadCSV);
    downloadMdBtn.addEventListener('click', downloadMarkdown);

    // ========== LATENCY TESTING FUNCTIONALITY ==========
    const latencyTester = document.getElementById('latencyTester');
    const selectAllTestBtn = document.getElementById('selectAllTestBtn');
    const selectTop10Btn = document.getElementById('selectTop10Btn');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const runLatencyTestBtn = document.getElementById('runLatencyTestBtn');
    const runTokenTestBtn = document.getElementById('runTokenTestBtn');
    const testPromptInput = document.getElementById('testPrompt');
    const latencyResults = document.getElementById('latencyResults');

    let selectedForTest = new Set();
    let testingInProgress = false;
    let availableTokenFiles = [];
    let tokenTestResults = {}; // Store loaded test results

    // Show latency tester when models are loaded
    function showLatencyTester() {
        if (latencyTester && allModels.length > 0) {
            latencyTester.style.display = 'block';
        }
    }

    // Load available token files
    async function loadTokenFiles() {
        try {
            const response = await fetch('/api/token-files');
            if (response.ok) {
                const data = await response.json();
                availableTokenFiles = data.files;
                console.log('üìÅ Available token files:', availableTokenFiles);
            }
        } catch (error) {
            console.warn('Could not load token files:', error);
        }
    }

    // Load token test results
    async function loadTokenTestResults() {
        try {
            const response = await fetch('/api/token-test-results');
            if (response.ok) {
                tokenTestResults = await response.json();
                console.log('‚úÖ Loaded token test results for', Object.keys(tokenTestResults).length, 'models');
            }
        } catch (error) {
            console.warn('Could not load token test results:', error);
        }
    }

    // Save token test result
    async function saveTokenTestResult(modelName, result) {
        try {
            const response = await fetch('/api/token-test-results', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ modelName, result })
            });
            
            if (response.ok) {
                const data = await response.json();
                tokenTestResults[modelName] = data.result;
                console.log('üíæ Saved token test result for', modelName);
            }
        } catch (error) {
            console.warn('Could not save token test result:', error);
        }
    }

    // Add checkboxes to model rows
    function addTestCheckboxes() {
        const sortedModels = sortModelsData(allModels, currentSort.column, currentSort.direction);
        const modelRows = document.querySelectorAll('.model-row');
        modelRows.forEach((row, index) => {
            if (!row.querySelector('.test-checkbox')) {
                const model = sortedModels[index];
                if (!model) return;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'test-checkbox';
                checkbox.dataset.modelName = model.name;
                checkbox.dataset.modelTemplate = model.standard_template || 'custom';
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', updateTestSelection);
                
                const nameCell = row.querySelector('.model-name');
                if (nameCell) {
                    nameCell.insertBefore(checkbox, nameCell.firstChild);
                }
            }
        });
    }

    function updateTestSelection() {
        selectedForTest.clear();
        document.querySelectorAll('.test-checkbox:checked').forEach(cb => {
            selectedForTest.add(cb.dataset.modelName);
        });
        updateTestButton();
    }

    function updateTestButton() {
        const count = selectedForTest.size;
        runLatencyTestBtn.textContent = `Run Test (${count} selected)`;
        runLatencyTestBtn.disabled = count === 0 || testingInProgress;
        runTokenTestBtn.textContent = `Run Token Test (${count} selected)`;
        runTokenTestBtn.disabled = count === 0 || testingInProgress;
    }

    selectAllTestBtn.addEventListener('click', () => {
        document.querySelectorAll('.test-checkbox').forEach(cb => {
            cb.checked = true;
        });
        updateTestSelection();
    });

    selectTop10Btn.addEventListener('click', () => {
        document.querySelectorAll('.test-checkbox').forEach((cb, idx) => {
            cb.checked = idx < 10;
        });
        updateTestSelection();
    });

    clearSelectionBtn.addEventListener('click', () => {
        document.querySelectorAll('.test-checkbox').forEach(cb => {
            cb.checked = false;
        });
        updateTestSelection();
    });

    runLatencyTestBtn.addEventListener('click', async () => {
        if (testingInProgress || selectedForTest.size === 0) return;

        testingInProgress = true;
        runLatencyTestBtn.disabled = true;
        runTokenTestBtn.disabled = true;
        runLatencyTestBtn.textContent = 'Testing...';

        const testPrompt = testPromptInput.value.trim() || 'Write a haiku about programming.';
        
        // Get models by their names from the selected set
        const modelsToTest = Array.from(selectedForTest)
            .map(modelName => allModels.find(m => m.name === modelName))
            .filter(m => m && (m.standard_template === 'vllm' || m.standard_template === 'tgi'));

        if (modelsToTest.length === 0) {
            alert('No valid text generation models selected. Please select VLLM or TGI models.');
            testingInProgress = false;
            updateTestButton();
            return;
        }

        // Clear previous results
        latencyResults.innerHTML = '<div style="color: var(--color-text); margin-bottom: 1rem;">Testing in progress...</div>';

        const results = [];

        for (const model of modelsToTest) {
            const result = await testModelLatency(model, testPrompt);
            results.push(result);
            displayLatencyResults(results);
        }

        testingInProgress = false;
        updateTestButton();
    });

    runTokenTestBtn.addEventListener('click', async () => {
        if (testingInProgress || selectedForTest.size === 0) return;

        testingInProgress = true;
        runLatencyTestBtn.disabled = true;
        runTokenTestBtn.disabled = true;
        runTokenTestBtn.textContent = 'Token Testing...';

        // Get models by their names from the selected set
        const modelsToTest = Array.from(selectedForTest)
            .map(modelName => allModels.find(m => m.name === modelName))
            .filter(m => m && (m.standard_template === 'vllm' || m.standard_template === 'tgi'));

        if (modelsToTest.length === 0) {
            alert('No valid text generation models selected. Please select VLLM or TGI models.');
            testingInProgress = false;
            updateTestButton();
            return;
        }

        // Clear previous results
        latencyResults.innerHTML = '<div style="color: var(--color-text); margin-bottom: 1rem;">Token testing in progress...</div>';

        const results = [];

        for (const model of modelsToTest) {
            const result = await testModelWithTokenFile(model);
            results.push(result);
            
            // Save successful test results
            if (result.status === 'success') {
                await saveTokenTestResult(result.name, {
                    status: result.status,
                    latency: result.latency,
                    tokenFile: result.tokenFile,
                    tokenCount: result.inputTokens,
                    inputContext: result.inputContext,
                    inputTokens: result.usage.prompt_tokens,
                    outputTokens: result.usage.completion_tokens,
                    totalTokens: result.usage.total_tokens
                });
            }
            
            displayLatencyResults(results);
        }

        testingInProgress = false;
        updateTestButton();
        
        // Refresh the model display to show new verification badges
        displayModels({ items: allModels, total: totalModels });
    });

    async function testModelLatency(model, prompt) {
        const startTime = performance.now();
        
        try {
            const response = await fetch('/api/test-model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: model.name,
                    prompt: prompt
                })
            });

            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);

            if (!response.ok) {
                const errorData = await response.json();
                return {
                    name: model.name,
                    status: 'error',
                    latency: latency,
                    error: errorData.error || 'Request failed'
                };
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || '(Empty response)';
            const usage = data.usage || {};

            return {
                name: model.name,
                status: 'success',
                latency: latency,
                response: content,
                usage: {
                    prompt_tokens: usage.prompt_tokens || 0,
                    completion_tokens: usage.completion_tokens || 0,
                    total_tokens: usage.total_tokens || 0
                }
            };
        } catch (error) {
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);
            
            return {
                name: model.name,
                status: 'error',
                latency: latency,
                error: error.message
            };
        }
    }

    // Select appropriate token file based on model's input context
    function selectTokenFile(inputContext) {
        if (!inputContext || availableTokenFiles.length === 0) {
            console.warn('No input context or no token files available');
            return null;
        }

        // We need to leave room for the output tokens (max_tokens parameter)
        // Typical max_tokens is 4000-16000, so we'll be conservative and reserve 20k tokens
        const RESERVED_OUTPUT_TOKENS = 20000;
        const maxInputTokens = inputContext - RESERVED_OUTPUT_TOKENS;

        // Find the largest token file that's smaller than the adjusted limit
        const suitableFiles = availableTokenFiles.filter(f => f.tokenCount < maxInputTokens);
        
        if (suitableFiles.length === 0) {
            // If no suitable file found, use the smallest one
            console.warn(`No token file smaller than ${maxInputTokens} (context: ${inputContext} - ${RESERVED_OUTPUT_TOKENS}), using smallest available`);
            return availableTokenFiles[0];
        }

        // Return the largest file that's still smaller than the adjusted context
        const selectedFile = suitableFiles[suitableFiles.length - 1];
        console.log(`Selected ${selectedFile.filename} (${selectedFile.tokenCount} tokens) for context ${inputContext} (max input: ${maxInputTokens})`);
        return selectedFile;
    }

    async function testModelWithTokenFile(model) {
        const startTime = performance.now();
        
        try {
            // Get model's input context from v1 data
            const v1Model = v1ModelsMap.get(model.name);
            const inputContext = v1Model?.context_length;

            if (!inputContext) {
                return {
                    name: model.name,
                    status: 'error',
                    latency: 0,
                    error: 'Model has no input context information'
                };
            }

            // Select appropriate token file
            const tokenFile = selectTokenFile(inputContext);
            
            if (!tokenFile) {
                return {
                    name: model.name,
                    status: 'error',
                    latency: 0,
                    error: 'No suitable token file found'
                };
            }

            console.log(`üìÑ Testing ${model.name} (context: ${inputContext}) with ${tokenFile.filename} (${tokenFile.tokenCount} tokens)`);

            // Fetch the token file content
            const tokenResponse = await fetch(tokenFile.path);
            if (!tokenResponse.ok) {
                throw new Error('Failed to load token file');
            }
            const tokenContent = await tokenResponse.text();

            // Test the model with the token content
            const response = await fetch('/api/test-model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: model.name,
                    prompt: tokenContent,
                    max_tokens: 1000,  // Use smaller max_tokens for token tests to avoid exceeding context
                    testType: 'token'
                })
            });

            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);

            if (!response.ok) {
                const errorData = await response.json();
                return {
                    name: model.name,
                    status: 'error',
                    latency: latency,
                    error: errorData.error || 'Request failed',
                    tokenFile: tokenFile.filename,
                    inputContext: inputContext
                };
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || '(Empty response)';
            const usage = data.usage || {};

            return {
                name: model.name,
                status: 'success',
                latency: latency,
                response: content,
                usage: {
                    prompt_tokens: usage.prompt_tokens || 0,
                    completion_tokens: usage.completion_tokens || 0,
                    total_tokens: usage.total_tokens || 0
                },
                tokenFile: tokenFile.filename,
                inputContext: inputContext,
                inputTokens: tokenFile.tokenCount
            };
        } catch (error) {
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);
            
            return {
                name: model.name,
                status: 'error',
                latency: latency,
                error: error.message,
                tokenFile: tokenFile?.filename,
                inputContext: inputContext
            };
        }
    }

    function displayLatencyResults(results) {
        console.log('Displaying results for', results.length, 'models');
        
        const successCount = results.filter(r => r.status === 'success').length;
        const errorCount = results.filter(r => r.status === 'error').length;
        const avgLatency = successCount > 0
            ? Math.round(results.filter(r => r.status === 'success').reduce((sum, r) => sum + r.latency, 0) / successCount)
            : 0;

        let html = `
            <div style="margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border-radius: 8px; border: 1px solid var(--color-border);">
                <h3 style="margin: 0 0 0.5rem 0; color: var(--color-text);">Test Results (${results.length} models tested)</h3>
                <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
                    <div><strong>Success:</strong> ${successCount}</div>
                    <div><strong>Failed:</strong> ${errorCount}</div>
                    <div><strong>Avg Latency:</strong> ${avgLatency}ms</div>
                    <div><strong>In Progress:</strong> ${results.length - successCount - errorCount}</div>
                </div>
            </div>
            <div style="display: grid; gap: 1rem; grid-template-columns: 1fr;">
        `;

        results.forEach((result, index) => {
            console.log(`Result ${index + 1}:`, result.name, result.status);
            
            const statusColor = result.status === 'success' ? 'var(--color-success)' : 'var(--color-error)';
            const statusIcon = result.status === 'success' ? '‚úÖ' : '‚ùå';

            html += `
                <div style="padding: 1rem; background: var(--color-surface); border-radius: 8px; border: 1px solid var(--color-border); margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; flex-wrap: wrap; gap: 0.5rem;">
                        <strong style="color: var(--color-text); flex: 1; min-width: 200px;">${index + 1}. ${result.name}</strong>
                        <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                            <span style="color: ${statusColor};">${statusIcon} ${result.status.toUpperCase()}</span>
                            <span style="color: var(--color-accent); font-weight: bold;">${result.latency}ms</span>
                            ${result.usage ? `
                                <span style="color: var(--color-text-muted); font-size: 0.85rem;">
                                    üìä ${result.usage.completion_tokens} tokens
                                </span>
                            ` : ''}
                        </div>
                    </div>
                    ${result.tokenFile ? `
                        <div style="color: var(--color-accent); font-size: 0.85rem; margin-top: 0.5rem; padding: 0.5rem; background: var(--color-bg); border-radius: 4px;">
                            üìÑ <strong>Token Test:</strong> Used ${result.tokenFile} | Model Context: ${formatNumber(result.inputContext)}
                        </div>
                    ` : ''}
                    ${result.error ? `<div style="color: var(--color-error); font-size: 0.9rem; margin-top: 0.5rem;">‚ùå Error: ${result.error}</div>` : ''}
                    ${result.usage ? `
                        <div style="color: var(--color-text-muted); font-size: 0.85rem; margin-top: 0.5rem; padding: 0.5rem; background: var(--color-bg); border-radius: 4px;">
                            <strong>Token Usage:</strong> Input: ${result.usage.prompt_tokens} | Output: ${result.usage.completion_tokens} | Total: ${result.usage.total_tokens}
                        </div>
                    ` : ''}
                    ${result.response ? `
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: var(--color-bg); border-radius: 4px; border-left: 3px solid var(--color-accent);">
                            <div style="font-weight: bold; color: var(--color-text); margin-bottom: 0.5rem; font-size: 0.9rem;">Response:</div>
                            <div style="color: var(--color-text); font-size: 0.9rem; line-height: 1.6; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(result.response)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
        });

        html += '</div>';
        latencyResults.innerHTML = html;
    }

    // Initial load - fetch v1 models first for modality info
    fetchV1Models().then(() => {
        // Load token files for token testing
        loadTokenFiles();
        // Load existing token test results
        loadTokenTestResults();
        fetchModels();
    });

    // Donation accordion toggle
    const donationToggle = document.querySelector('.donation-toggle');
    const donationContent = document.getElementById('donationDetails');
    if (donationToggle && donationContent) {
        donationToggle.addEventListener('click', function() {
            const expanded = donationToggle.getAttribute('aria-expanded') === 'true';
            donationToggle.setAttribute('aria-expanded', String(!expanded));
            donationToggle.classList.toggle('open', !expanded);
            donationContent.hidden = expanded;
        });
    }
});

</code>

public\styles.css:
<code>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --font-family-base: 'Sansation', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',
        'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}

body {
    font-family: var(--font-family-base);
    line-height: 1.6;
    background-color: var(--color-bg);
    color: var(--color-text);
    min-height: 100vh;
    padding: 32px 20px;
    transition: background-color 0.25s ease, color 0.25s ease;
}

/* Light - Default Theme */
body[data-theme='light-default'] {
    --color-bg: #edf1f7;
    --color-surface: #ffffff;
    --color-surface-alt: #f5f7fb;
    --color-border: #d6dbe6;
    --color-heading: #111827;
    --color-text: #1f2933;
    --color-text-muted: #4b5563;
    --color-accent: #1d4ed8;
    --color-accent-hover: #1e3a8a;
    --color-accent-contrast: #ffffff;
    --color-badge-bg: #fde68a;
    --color-badge-text: #7c2d12;
    --color-table-header-bg: #111827;
    --color-table-header-text: #f9fafb;
    --color-row-hover: rgba(17, 24, 39, 0.04);
    --color-chip-bg: #e0e7ff;
    --color-chip-text: #1e3a8a;
    --color-status-active: #22c55e;
    --color-status-inactive: #ef4444;
    --color-status-hot: #f97316;
    --color-button-secondary-bg: transparent;
    --color-button-secondary-border: #1d4ed8;
    --color-button-secondary-text: #1d4ed8;
    --shadow-elevated: 0 24px 48px -28px rgba(15, 23, 42, 0.35);
    --modality-text-bg: #fef3c7;
    --modality-text-text: #92400e;
    --modality-image-bg: #fce7f3;
    --modality-image-text: #9f1239;
    --modality-audio-bg: #ddd6fe;
    --modality-audio-text: #5b21b6;
    --modality-video-bg: #bbf7d0;
    --modality-video-text: #14532d;
    --modality-other-bg: #e0e7ff;
    --modality-other-text: #1e3a8a;
}

/* Light - Warm Theme */
body[data-theme='light-warm'] {
    --color-bg: #fef8f3;
    --color-surface: #ffffff;
    --color-surface-alt: #fef3e2;
    --color-border: #e8d5c4;
    --color-heading: #7c2d12;
    --color-text: #78350f;
    --color-text-muted: #92400e;
    --color-accent: #c2410c;
    --color-accent-hover: #9a3412;
    --color-accent-contrast: #ffffff;
    --color-badge-bg: #fed7aa;
    --color-badge-text: #7c2d12;
    --color-table-header-bg: #7c2d12;
    --color-table-header-text: #fef3e2;
    --color-row-hover: rgba(124, 45, 18, 0.04);
    --color-chip-bg: #fed7aa;
    --color-chip-text: #7c2d12;
    --color-status-active: #22c55e;
    --color-status-inactive: #ef4444;
    --color-status-hot: #f97316;
    --color-button-secondary-bg: transparent;
    --color-button-secondary-border: #c2410c;
    --color-button-secondary-text: #c2410c;
    --shadow-elevated: 0 24px 48px -28px rgba(124, 45, 18, 0.25);
    --modality-text-bg: #fef3c7;
    --modality-text-text: #92400e;
    --modality-image-bg: #fce7f3;
    --modality-image-text: #9f1239;
    --modality-audio-bg: #ddd6fe;
    --modality-audio-text: #5b21b6;
    --modality-video-bg: #bbf7d0;
    --modality-video-text: #14532d;
    --modality-other-bg: #e0e7ff;
    --modality-other-text: #1e3a8a;
}

/* Dark - Default Theme */
body[data-theme='dark-default'] {
    --color-bg: #060b16;
    --color-surface: #0f172a;
    --color-surface-alt: #101d37;
    --color-border: rgba(148, 163, 184, 0.32);
    --color-heading: rgba(255, 255, 255, 0.94);
    --color-text: rgba(238, 242, 255, 0.92);
    --color-text-muted: rgba(203, 213, 225, 0.68);
    --color-accent: #60a5fa;
    --color-accent-hover: #3b82f6;
    --color-accent-contrast: #060b16;
    --color-badge-bg: rgba(250, 204, 21, 0.18);
    --color-badge-text: rgba(250, 204, 21, 0.9);
    --color-table-header-bg: rgba(8, 28, 58, 0.92);
    --color-table-header-text: rgba(255, 255, 255, 0.9);
    --color-row-hover: rgba(96, 165, 250, 0.08);
    --color-chip-bg: rgba(37, 99, 235, 0.22);
    --color-chip-text: #bfdbfe;
    --color-status-active: #34d399;
    --color-status-inactive: #f87171;
    --color-status-hot: #fb923c;
    --color-button-secondary-bg: rgba(255, 255, 255, 0.04);
    --color-button-secondary-border: rgba(148, 163, 184, 0.55);
    --color-button-secondary-text: rgba(255, 255, 255, 0.86);
    --shadow-elevated: 0 32px 60px -28px rgba(7, 23, 55, 0.75);
    --modality-text-bg: rgba(250, 204, 21, 0.22);
    --modality-text-text: #fde047;
    --modality-image-bg: rgba(244, 63, 94, 0.22);
    --modality-image-text: #fda4af;
    --modality-audio-bg: rgba(168, 85, 247, 0.22);
    --modality-audio-text: #e9d5ff;
    --modality-video-bg: rgba(34, 197, 94, 0.22);
    --modality-video-text: #86efac;
    --modality-other-bg: rgba(59, 130, 246, 0.22);
    --modality-other-text: #93c5fd;
    font-weight: 300;
}

/* Dark - Vibrant Theme (High Contrast, Bright Colors) */
body[data-theme='dark-vibrant'] {
    --color-bg: #000000;
    --color-surface: #0a0a0a;
    --color-surface-alt: #141414;
    --color-border: rgba(255, 255, 255, 0.25);
    --color-heading: #ffffff;
    --color-text: rgba(255, 255, 255, 0.95);
    --color-text-muted: rgba(255, 255, 255, 0.72);
    --color-accent: #00d9ff;
    --color-accent-hover: #00b8d4;
    --color-accent-contrast: #000000;
    --color-badge-bg: rgba(255, 215, 0, 0.25);
    --color-badge-text: #ffd700;
    --color-table-header-bg: #000000;
    --color-table-header-text: #ffffff;
    --color-row-hover: rgba(0, 217, 255, 0.12);
    --color-chip-bg: rgba(0, 217, 255, 0.25);
    --color-chip-text: #00ffff;
    --color-status-active: #00ff00;
    --color-status-inactive: #ff0055;
    --color-status-hot: #ff6600;
    --color-button-secondary-bg: rgba(255, 255, 255, 0.06);
    --color-button-secondary-border: rgba(255, 255, 255, 0.6);
    --color-button-secondary-text: #ffffff;
    --shadow-elevated: 0 32px 60px -28px rgba(0, 217, 255, 0.35);
    --modality-text-bg: rgba(255, 215, 0, 0.3);
    --modality-text-text: #ffff00;
    --modality-image-bg: rgba(255, 20, 147, 0.3);
    --modality-image-text: #ff1493;
    --modality-audio-bg: rgba(138, 43, 226, 0.3);
    --modality-audio-text: #da70d6;
    --modality-video-bg: rgba(0, 255, 127, 0.3);
    --modality-video-text: #00ff7f;
    --modality-other-bg: rgba(0, 191, 255, 0.3);
    --modality-other-text: #00bfff;
    font-weight: 300;
}

/* Dark - Midnight Theme */
body[data-theme='dark-midnight'] {
    --color-bg: #0d1117;
    --color-surface: #161b22;
    --color-surface-alt: #1c2128;
    --color-border: rgba(110, 118, 129, 0.4);
    --color-heading: rgba(255, 255, 255, 0.93);
    --color-text: rgba(201, 209, 217, 0.91);
    --color-text-muted: rgba(139, 148, 158, 0.75);
    --color-accent: #58a6ff;
    --color-accent-hover: #1f6feb;
    --color-accent-contrast: #0d1117;
    --color-badge-bg: rgba(187, 128, 9, 0.25);
    --color-badge-text: #f0c430;
    --color-table-header-bg: #0d1117;
    --color-table-header-text: rgba(255, 255, 255, 0.88);
    --color-row-hover: rgba(88, 166, 255, 0.08);
    --color-chip-bg: rgba(88, 166, 255, 0.2);
    --color-chip-text: #79c0ff;
    --color-status-active: #3fb950;
    --color-status-inactive: #f85149;
    --color-status-hot: #db6d28;
    --color-button-secondary-bg: rgba(255, 255, 255, 0.04);
    --color-button-secondary-border: rgba(110, 118, 129, 0.6);
    --color-button-secondary-text: rgba(201, 209, 217, 0.9);
    --shadow-elevated: 0 32px 60px -28px rgba(1, 4, 9, 0.8);
    --modality-text-bg: rgba(187, 128, 9, 0.25);
    --modality-text-text: #d29922;
    --modality-image-bg: rgba(218, 54, 51, 0.25);
    --modality-image-text: #ff7b72;
    --modality-audio-bg: rgba(163, 113, 247, 0.25);
    --modality-audio-text: #d2a8ff;
    --modality-video-bg: rgba(63, 185, 80, 0.25);
    --modality-video-text: #56d364;
    --modality-other-bg: rgba(88, 166, 255, 0.25);
    --modality-other-text: #79c0ff;
    font-weight: 300;
}

a {
    color: var(--color-accent);
    text-decoration: none;
    font-weight: 600;
    transition: color 0.2s ease;
}

a:hover {
    color: var(--color-accent-hover);
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: var(--color-surface);
    border-radius: 18px;
    border: 1px solid var(--color-border);
    box-shadow: var(--shadow-elevated);
    overflow: hidden;
    transition: background 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
}

header {
    padding: 32px;
    background: var(--color-surface-alt);
    border-bottom: 1px solid var(--color-border);
    transition: background 0.25s ease, border-color 0.25s ease;
}

.header-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
}

header h1 {
    font-size: 2.3rem;
    font-weight: 700;
    color: var(--color-heading);
}

body[data-theme='dark-default'] header h1,
body[data-theme='dark-vibrant'] header h1,
body[data-theme='dark-midnight'] header h1 {
    font-weight: 500;
}

.badge-enhanced {
    background: var(--color-badge-bg);
    color: var(--color-badge-text);
    padding: 5px 14px;
    border-radius: 999px;
    font-size: 0.6em;
    font-weight: 700;
    margin-left: 10px;
    border: 1px solid rgba(0, 0, 0, 0.06);
}

header p {
    font-size: 1.05rem;
    color: var(--color-text-muted);
    margin-top: 12px;
}

.header-actions {
    display: flex;
    gap: 12px;
    align-items: center;
}

.theme-selector-label {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--color-text-muted);
    font-weight: 700;
}

.theme-selector {
    padding: 8px 14px;
    border-radius: 10px;
    border: 1px solid var(--color-border);
    background: var(--color-surface);
    color: var(--color-text);
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: border-color 0.2s ease, background 0.2s ease;
    min-width: 180px;
}

.theme-selector:focus {
    outline: none;
    border-color: var(--color-accent);
    box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.12);
}

body[data-theme='dark-default'] .theme-selector:focus,
body[data-theme='dark-vibrant'] .theme-selector:focus,
body[data-theme='dark-midnight'] .theme-selector:focus {
    box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.15);
}

.controls {
    margin-top: 26px;
    display: flex;
    align-items: stretch;
    gap: 16px;
    flex-wrap: wrap;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 14px;
    padding: 16px;
    transition: background 0.25s ease, border-color 0.25s ease;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 190px;
}

.control-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--color-text-muted);
    font-weight: 700;
}

.control-input {
    padding: 8px 14px;
    border-radius: 10px;
    border: 1px solid var(--color-border);
    background: var(--color-surface-alt);
    color: var(--color-text);
    font-size: 0.95rem;
    transition: border-color 0.2s ease, background 0.2s ease;
}

.control-input:focus {
    outline: none;
    border-color: var(--color-accent);
    background: var(--color-surface);
    box-shadow: 0 0 0 3px rgba(29, 78, 216, 0.12);
}

body[data-theme='dark-default'] .control-input:focus,
body[data-theme='dark-vibrant'] .control-input:focus,
body[data-theme='dark-midnight'] .control-input:focus {
    box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.15);
}

.control-spacer {
    flex: 1 1 120px;
}

button {
    font-family: inherit;
    cursor: pointer;
}

.action-button {
    padding: 10px 22px;
    border-radius: 10px;
    border: none;
    background: var(--color-accent);
    color: var(--color-accent-contrast);
    font-weight: 600;
    font-size: 0.95rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

.action-button:hover:not(:disabled) {
    transform: translateY(-1px);
    background: var(--color-accent-hover);
    box-shadow: 0 10px 30px -20px rgba(29, 78, 216, 0.65);
}

.action-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
}

.ghost-button {
    padding: 10px 18px;
    border-radius: 10px;
    border: 1px solid var(--color-button-secondary-border);
    background: var(--color-button-secondary-bg);
    color: var(--color-button-secondary-text);
    font-weight: 600;
    font-size: 0.9rem;
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
}

.ghost-button:hover {
    transform: translateY(-1px);
    background: rgba(29, 78, 216, 0.08);
}

body[data-theme='dark-default'] .ghost-button:hover,
body[data-theme='dark-vibrant'] .ghost-button:hover,
body[data-theme='dark-midnight'] .ghost-button:hover {
    background: rgba(148, 163, 184, 0.14);
}

main {
    padding: 32px;
}

.stats {
    display: flex;
    gap: 24px;
    justify-content: center;
    margin-bottom: 24px;
    padding: 18px 24px;
    background: var(--color-surface-alt);
    border-radius: 14px;
    border: 1px solid var(--color-border);
    transition: background 0.25s ease, border-color 0.25s ease;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
}

.stat-value {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--color-accent);
}

.cache-status .stat-label {
    font-size: 0.7rem;
}

.cache-status .stat-value {
    font-size: 0.85rem;
    line-height: 1.3;
}

.cache-status .stat-value small {
    font-size: 0.75rem;
    opacity: 0.8;
}

.resource-links {
    display: flex;
    gap: 16px;
    justify-content: center;
    margin-bottom: 24px;
    padding: 0 24px;
    flex-wrap: wrap;
}

.resource-link {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 24px;
    background: var(--color-surface-alt);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    color: var(--color-text);
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    text-decoration: none;
}

.resource-link:hover {
    transform: translateY(-2px);
    background: var(--color-accent);
    color: var(--color-accent-contrast);
    border-color: var(--color-accent);
    box-shadow: 0 8px 24px -12px var(--color-accent);
}

.link-icon {
    font-size: 1.3rem;
}

.link-text {
    flex: 1;
}

.link-arrow {
    font-size: 1.1rem;
    font-weight: 700;
    opacity: 0.7;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

.resource-link:hover .link-arrow {
    transform: translateX(4px);
    opacity: 1;
}

.donation-accordion {
    width: 100%;
}

.donation-toggle {
    width: 100%;
    border: 2px solid #22c55e;
    background: #22c55e;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 14px 24px;
    background: var(--color-surface-alt);
    border-radius: 12px;
    color: var(--color-text);
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    text-decoration: none;
    justify-content: space-between;
}

.donation-toggle:hover {
    transform: translateY(-2px);
    background: #86efac;
    color: var(--color-text);
    border-color: #22c55e;
    box-shadow: 0 8px 24px -12px #22c55e;
}

.donation-toggle .accordion-arrow {
    font-size: 1.1rem;
    font-weight: 700;
    transition: transform 0.3s ease;
}

.donation-toggle.open .accordion-arrow {
    transform: rotate(180deg);
}

.donation-content {
    padding: 16px 24px;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 0 0 12px 12px;
    margin-top: 1px;
    color: var(--color-text);
    font-size: 0.9rem;
    line-height: 1.5;
}

.donation-content[hidden] {
    display: none !important;
}

.donation-content p {
    margin-bottom: 12px;
}

.donation-toggle a {
    color: inherit;
    text-decoration: underline;
}

.donation-toggle:hover a {
    color: var(--color-accent);
}

.loading {
    text-align: center;
    padding: 70px 20px;
}

.spinner {
    border: 4px solid rgba(148, 163, 184, 0.2);
    border-top: 4px solid var(--color-accent);
    border-radius: 50%;
    width: 52px;
    height: 52px;
    animation: spin 1s linear infinite;
    margin: 0 auto 18px;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}

.error {
    background: rgba(248, 113, 113, 0.12);
    border: 1px solid rgba(248, 113, 113, 0.35);
    color: #b91c1c;
    padding: 18px 24px;
    border-radius: 12px;
    text-align: center;
    font-weight: 600;
}

body[data-theme='dark-default'] .error,
body[data-theme='dark-vibrant'] .error,
body[data-theme='dark-midnight'] .error {
    color: #fecaca;
    background: rgba(239, 68, 68, 0.12);
    border-color: rgba(239, 68, 68, 0.45);
}

.hidden {
    display: none !important;
}

.models-container {
    display: flex;
    flex-direction: column;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 14px;
    overflow: hidden;
    transition: background 0.25s ease, border-color 0.25s ease;
}

.table-header {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr 0.8fr 0.9fr 1fr 1fr 1fr 0.8fr 0.8fr;
    background: var(--color-table-header-bg);
    color: var(--color-table-header-text);
    font-weight: 700;
    font-size: 0.82rem;
    letter-spacing: 0.02em;
}

.header-cell {
    padding: 14px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
    transition: background 0.2s ease, color 0.2s ease;
}

.header-cell:hover {
    background: rgba(255, 255, 255, 0.08);
}

.sort-indicator {
    opacity: 0.6;
    font-size: 0.85rem;
    margin-left: 8px;
}

.sort-indicator.active {
    opacity: 1;
    font-weight: 900;
}

.model-row {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr 0.8fr 0.9fr 1fr 1fr 1fr 0.8fr 0.8fr;
    border-top: 1px solid var(--color-border);
    transition: background 0.2s ease, transform 0.2s ease;
}

.model-row:first-of-type {
    border-top: none;
}

.model-row:hover {
    background: var(--color-row-hover);
    transform: translateX(3px);
}

.model-cell {
    padding: 14px 16px;
    font-size: 0.88rem;
    display: flex;
    align-items: center;
    gap: 6px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.model-cell.input-context,
.model-cell.output-context {
    flex-direction: column;
    align-items: center;
    gap: 2px;
    justify-content: center;
}

.model-cell.model-name {
    font-weight: 600;
}

.model-link {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    color: var(--color-text);
}

.model-link:hover {
    color: var(--color-accent);
}

body[data-theme='dark-default'] .model-link,
body[data-theme='dark-vibrant'] .model-link,
body[data-theme='dark-midnight'] .model-link {
    color: rgba(255, 255, 255, 0.92);
}

.model-cell.template {
    font-weight: 600;
}

.template-badge {
    display: inline-flex;
    align-items: center;
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 0.72rem;
    font-weight: 700;
    letter-spacing: 0.04em;
    border: 1px solid currentColor;
    background: transparent;
}

.template-badge.vllm {
    color: #1d4ed8;
}

body[data-theme='dark-default'] .template-badge.vllm,
body[data-theme='dark-vibrant'] .template-badge.vllm,
body[data-theme='dark-midnight'] .template-badge.vllm {
    color: #93c5fd;
}

.template-badge.comfyui {
    color: #7b1fa2;
}

body[data-theme='dark-default'] .template-badge.comfyui,
body[data-theme='dark-vibrant'] .template-badge.comfyui,
body[data-theme='dark-midnight'] .template-badge.comfyui {
    color: #e9d5ff;
}

.template-badge.tgi {
    color: #15803d;
}

body[data-theme='dark-default'] .template-badge.tgi,
body[data-theme='dark-vibrant'] .template-badge.tgi,
body[data-theme='dark-midnight'] .template-badge.tgi {
    color: #86efac;
}

.template-badge.custom {
    color: #b45309;
}

body[data-theme='dark-default'] .template-badge.custom,
body[data-theme='dark-vibrant'] .template-badge.custom,
body[data-theme='dark-midnight'] .template-badge.custom {
    color: #fcd34d;
}

.price {
    font-family: 'Courier New', Courier, monospace;
    font-weight: 600;
}

.invocations {
    color: var(--color-text-muted);
    font-weight: 600;
}

.modalities {
    flex-direction: column !important;
    align-items: flex-start !important;
    gap: 6px;
}

.modalities small {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
}

.modality-badge {
    display: inline-block;
    padding: 3px 9px;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.02em;
    text-transform: lowercase;
}

.modality-badge.text {
    background: var(--modality-text-bg);
    color: var(--modality-text-text);
}

.modality-badge.image {
    background: var(--modality-image-bg);
    color: var(--modality-image-text);
}

.modality-badge.audio {
    background: var(--modality-audio-bg);
    color: var(--modality-audio-text);
}

.modality-badge.video {
    background: var(--modality-video-bg);
    color: var(--modality-video-text);
}

.modality-badge.other {
    background: var(--modality-other-bg);
    color: var(--modality-other-text);
}

.modality-arrow {
    color: var(--color-text-muted);
    font-weight: 700;
    margin: 0 2px;
}

.features-mini {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.feature-mini {
    background: var(--color-chip-bg);
    color: var(--color-chip-text);
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 0.65rem;
    font-weight: 600;
}

.quant-badge {
    background: var(--color-chip-bg);
    color: var(--color-chip-text);
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
    display: inline-block;
}

.gpu-toggle {
    background: transparent;
    color: var(--color-accent);
    border: 1px solid var(--color-accent);
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 0.78rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
}

.gpu-toggle:hover {
    background: var(--color-accent);
    color: var(--color-accent-contrast);
}

.gpu-details {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
    padding: 8px;
    background: var(--color-surface-alt);
    border-radius: 8px;
    border: 1px dashed var(--color-border);
}

.gpu-tag {
    background: var(--color-accent);
    color: var(--color-accent-contrast);
    padding: 3px 10px;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 600;
    letter-spacing: 0.04em;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.82rem;
    color: var(--color-text);
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.status-dot.active {
    background: var(--color-status-active);
}

.status-dot.inactive {
    background: var(--color-status-inactive);
}

.status-dot.hot {
    background: var(--color-status-hot);
    animation: pulse 2s infinite;
}

/* Verification Badge */
.verification-badge {
    display: block;
    font-size: 0.65rem;
    font-weight: 600;
    color: #15803d;
    background: transparent;
    border: none;
    cursor: help;
    margin-bottom: 2px;
    text-align: center;
}

body[data-theme='dark-default'] .verification-badge,
body[data-theme='dark-vibrant'] .verification-badge,
body[data-theme='dark-midnight'] .verification-badge {
    color: #86efac;
}

.verification-badge:hover {
    color: #16a34a;
    text-decoration: underline;
}

body[data-theme='dark-default'] .verification-badge:hover,
body[data-theme='dark-vibrant'] .verification-badge:hover,
body[data-theme='dark-midnight'] .verification-badge:hover {
    color: #4ade80;
}

@keyframes pulse {
    0%,
    100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 22px;
    margin-top: 34px;
    padding: 20px;
}

.page-btn {
    background: var(--color-accent);
    color: var(--color-accent-contrast);
    border: none;
    padding: 10px 22px;
    border-radius: 10px;
    font-size: 0.95rem;
    font-weight: 600;
    transition: transform 0.2s ease, background 0.2s ease;
}

.page-btn:hover:not(:disabled) {
    background: var(--color-accent-hover);
    transform: translateY(-1px);
}

.page-btn:disabled {
    background: rgba(148, 163, 184, 0.45);
    cursor: not-allowed;
}

#pageInfo {
    font-weight: 600;
    color: var(--color-text-muted);
}

/* Mobile: Enable horizontal scrolling for table */
@media (max-width: 768px) {
    body {
        font-size: 14px;
        padding: 16px 10px;
    }

    header {
        padding: 20px 16px;
    }

    header h1 {
        font-size: 1.5rem;
    }

    header p {
        font-size: 0.9rem;
    }

    main {
        padding: 16px;
    }

    .controls {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
    }

    .control-group,
    .ghost-button,
    .action-button {
        width: 100%;
    }

    .control-spacer {
        display: none;
    }

    .control-label {
        font-size: 0.85rem;
    }

    .control-input,
    .action-button,
    .ghost-button {
        font-size: 0.9rem;
        padding: 8px 12px;
    }

    /* Make table scrollable horizontally */
    .models-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        margin: 0 -16px;
        padding: 0 16px;
    }

    /* Show only Model Name, Input, Output as main columns, rest scrollable */
    .table-header,
    .model-row {
        grid-template-columns: 2fr 1fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr 0.8fr 0.9fr 1fr 1fr 1fr 0.8fr 0.8fr;
        min-width: 1500px; /* Force horizontal scroll for 15 columns */
    }

    .header-cell,
    .model-cell {
        font-size: 0.85rem;
        padding: 10px 8px;
    }

    .model-name {
        font-size: 0.9rem;
    }

    /* Stats adjustments */
    .stats {
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.85rem;
    }

    .stat-item {
        min-width: calc(50% - 8px);
    }

    /* Pagination adjustments */
    .pagination {
        font-size: 0.9rem;
        gap: 10px;
    }

    .page-btn {
        padding: 8px 12px;
        font-size: 0.85rem;
    }
}

/* Tablet: Reduce some columns but keep readable */
@media (min-width: 769px) and (max-width: 1200px) {
    .table-header,
    .model-row {
        grid-template-columns: 2fr 1fr 1.5fr 1fr 1fr;
    }

    .model-cell:nth-child(n + 6) {
        display: none;
    }

    .header-cell:nth-child(n + 6) {
        display: none;
    }
}

/* Large tablet/small desktop */
@media (min-width: 1201px) and (max-width: 1400px) {
    .table-header,
    .model-row {
        grid-template-columns: 2fr 1fr 1.5fr 1fr 1fr 1fr;
    }

    .model-cell:nth-child(n + 7) {
        display: none;
    }

    .header-cell:nth-child(n + 7) {
        display: none;
    }
}

/* Latency Testing Styles */
.latency-tester {
    margin-top: 2rem;
    padding: 1.5rem;
    background: var(--color-surface);
    border-radius: 12px;
    border: 1px solid var(--color-border);
}

.test-checkbox {
    cursor: pointer;
    width: 16px;
    height: 16px;
    accent-color: var(--color-accent);
}

.test-checkbox:hover {
    transform: scale(1.1);
}

.model-name {
    display: flex;
    align-items: center;
    gap: 8px;
}

#latencyResults {
    max-height: 600px;
    overflow-y: auto;
}

#latencyResults::-webkit-scrollbar {
    width: 8px;
}

#latencyResults::-webkit-scrollbar-track {
    background: var(--color-surface);
    border-radius: 4px;
}

#latencyResults::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 4px;
}

#latencyResults::-webkit-scrollbar-thumb:hover {
    background: var(--color-accent);
}

/* Response text scrollbar */
.latency-tester ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.latency-tester ::-webkit-scrollbar-track {
    background: var(--color-surface);
    border-radius: 4px;
}

.latency-tester ::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 4px;
}

.latency-tester ::-webkit-scrollbar-thumb:hover {
    background: var(--color-accent);
}

</code>

public\test-models.html:
<code>
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Chutes AI Model Latency Tester</title>
        
        <!-- Fonts -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Sansation:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
            rel="stylesheet"
        />
        
        <!-- React and ReactDOM from CDN -->
        <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
        <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
        
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            :root {
                --font-family-base: 'Sansation', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',
                    'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
                
                /* Dark theme colors matching the main app */
                --color-bg: #060b16;
                --color-surface: #0f172a;
                --color-surface-alt: #101d37;
                --color-border: rgba(148, 163, 184, 0.32);
                --color-heading: rgba(255, 255, 255, 0.94);
                --color-text: rgba(238, 242, 255, 0.92);
                --color-text-muted: rgba(203, 213, 225, 0.68);
                --color-accent: #60a5fa;
                --color-accent-hover: #3b82f6;
                --color-accent-contrast: #060b16;
                --color-status-active: #34d399;
                --color-status-inactive: #f87171;
                --color-status-pending: #fbbf24;
                --shadow-elevated: 0 32px 60px -28px rgba(7, 23, 55, 0.75);
            }

            body {
                font-family: var(--font-family-base);
                line-height: 1.6;
                background-color: var(--color-bg);
                color: var(--color-text);
                min-height: 100vh;
                padding: 32px 20px;
                font-weight: 300;
            }

            .container {
                max-width: 1600px;
                margin: 0 auto;
                background: var(--color-surface);
                border-radius: 18px;
                border: 1px solid var(--color-border);
                box-shadow: var(--shadow-elevated);
                overflow: hidden;
            }

            header {
                padding: 32px;
                background: var(--color-surface-alt);
                border-bottom: 1px solid var(--color-border);
            }

            h1 {
                font-size: 2.3rem;
                font-weight: 500;
                color: var(--color-heading);
                margin-bottom: 12px;
            }

            .subtitle {
                font-size: 1.05rem;
                color: var(--color-text-muted);
            }

            main {
                padding: 32px;
            }

            .controls {
                display: flex;
                gap: 16px;
                margin-bottom: 24px;
                flex-wrap: wrap;
                align-items: flex-end;
            }

            .control-group {
                display: flex;
                flex-direction: column;
                gap: 6px;
                flex: 1;
                min-width: 200px;
            }

            label {
                font-size: 0.75rem;
                text-transform: uppercase;
                letter-spacing: 0.06em;
                color: var(--color-text-muted);
                font-weight: 700;
            }

            input, textarea {
                padding: 10px 14px;
                border-radius: 10px;
                border: 1px solid var(--color-border);
                background: var(--color-surface-alt);
                color: var(--color-text);
                font-size: 0.95rem;
                font-family: inherit;
                transition: border-color 0.2s ease;
            }

            input:focus, textarea:focus {
                outline: none;
                border-color: var(--color-accent);
                box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.15);
            }

            textarea {
                resize: vertical;
                min-height: 80px;
            }

            button {
                padding: 10px 22px;
                border-radius: 10px;
                border: none;
                background: var(--color-accent);
                color: var(--color-accent-contrast);
                font-weight: 600;
                font-size: 0.95rem;
                cursor: pointer;
                transition: transform 0.2s ease, background 0.2s ease;
                font-family: inherit;
            }

            button:hover:not(:disabled) {
                transform: translateY(-1px);
                background: var(--color-accent-hover);
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .models-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
                gap: 24px;
            }

            .model-card {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 14px;
                padding: 20px;
                transition: border-color 0.3s ease;
            }

            .model-card.testing {
                border-color: var(--color-status-pending);
            }

            .model-card.success {
                border-color: var(--color-status-active);
            }

            .model-card.error {
                border-color: var(--color-status-inactive);
            }

            .model-header {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                margin-bottom: 16px;
                gap: 12px;
            }

            .model-name {
                font-size: 1.1rem;
                font-weight: 600;
                color: var(--color-heading);
                word-break: break-word;
            }

            .model-link {
                color: var(--color-accent);
                text-decoration: none;
                font-size: 0.85rem;
                white-space: nowrap;
            }

            .model-link:hover {
                color: var(--color-accent-hover);
            }

            .status-badge {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 6px 12px;
                border-radius: 999px;
                font-size: 0.85rem;
                font-weight: 600;
                margin-bottom: 12px;
            }

            .status-badge.pending {
                background: rgba(251, 191, 36, 0.2);
                color: var(--color-status-pending);
            }

            .status-badge.testing {
                background: rgba(96, 165, 250, 0.2);
                color: var(--color-accent);
            }

            .status-badge.success {
                background: rgba(52, 211, 153, 0.2);
                color: var(--color-status-active);
            }

            .status-badge.error {
                background: rgba(248, 113, 113, 0.2);
                color: var(--color-status-inactive);
            }

            .latency {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--color-accent);
                margin-bottom: 12px;
            }

            .response-box {
                background: var(--color-surface);
                border: 1px solid var(--color-border);
                border-radius: 8px;
                padding: 12px;
                max-height: 200px;
                overflow-y: auto;
                font-size: 0.9rem;
                color: var(--color-text-muted);
                white-space: pre-wrap;
                word-break: break-word;
            }

            .response-box:empty::before {
                content: 'No response yet...';
                color: var(--color-text-muted);
                opacity: 0.5;
            }

            .spinner {
                display: inline-block;
                width: 16px;
                height: 16px;
                border: 2px solid rgba(148, 163, 184, 0.2);
                border-top: 2px solid var(--color-accent);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            .summary {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 14px;
                padding: 20px;
                margin-bottom: 24px;
            }

            .summary h2 {
                font-size: 1.3rem;
                font-weight: 600;
                color: var(--color-heading);
                margin-bottom: 12px;
            }

            .summary-stats {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 16px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .stat-label {
                font-size: 0.8rem;
                color: var(--color-text-muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }

            .stat-value {
                font-size: 1.4rem;
                font-weight: 700;
                color: var(--color-accent);
            }

            .error-message {
                color: var(--color-status-inactive);
                font-size: 0.85rem;
                margin-top: 8px;
            }

            @media (max-width: 768px) {
                .models-grid {
                    grid-template-columns: 1fr;
                }
                
                h1 {
                    font-size: 1.8rem;
                }
            }
        </style>
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            const { useState, useEffect } = React;

            // Top 10 models from chutes-models.md
            const MODELS = [
                {
                    name: "deepseek-ai/DeepSeek-R1",
                    url: "https://chutes.ai/app/chute/de510462-c319-543b-9c67-00bcf807d2a7",
                    id: "de510462-c319-543b-9c67-00bcf807d2a7"
                },
                {
                    name: "deepseek-ai/DeepSeek-R1-0528",
                    url: "https://chutes.ai/app/chute/14a91d88-d6d6-5046-aaf4-eb3ad96b7247",
                    id: "14a91d88-d6d6-5046-aaf4-eb3ad96b7247"
                },
                {
                    name: "deepseek-ai/DeepSeek-V3-0324",
                    url: "https://chutes.ai/app/chute/154ad01c-a431-5744-83c8-651215124360",
                    id: "154ad01c-a431-5744-83c8-651215124360"
                },
                {
                    name: "tngtech/DeepSeek-TNG-R1T2-Chimera",
                    url: "https://chutes.ai/app/chute/4fa0c7f5-82f7-59d1-8996-661bb778893d",
                    id: "4fa0c7f5-82f7-59d1-8996-661bb778893d"
                },
                {
                    name: "deepseek-ai/DeepSeek-V3.1-Terminus",
                    url: "https://chutes.ai/app/chute/4bbc44e9-6bfc-5e21-a91d-129bff2fb6d4",
                    id: "4bbc44e9-6bfc-5e21-a91d-129bff2fb6d4"
                },
                {
                    name: "unsloth/gemma-3-4b-it",
                    url: "https://chutes.ai/app/chute/4d636d79-623c-5688-b57c-264f9e53d85d",
                    id: "4d636d79-623c-5688-b57c-264f9e53d85d"
                },
                {
                    name: "zai-org/GLM-4.5-Air",
                    url: "https://chutes.ai/app/chute/7fa03c12-823f-529a-8245-36432f03e9a1",
                    id: "7fa03c12-823f-529a-8245-36432f03e9a1"
                },
                {
                    name: "zai-org/GLM-4.6-FP8",
                    url: "https://chutes.ai/app/chute/1aec6931-3bb8-5f5e-a61c-b112276ed140",
                    id: "1aec6931-3bb8-5f5e-a61c-b112276ed140"
                },
                {
                    name: "unsloth/Mistral-Small-24B-Instruct-2501",
                    url: "https://chutes.ai/app/chute/986b874c-bf41-549f-b28f-4322f86fa4ba",
                    id: "986b874c-bf41-549f-b28f-4322f86fa4ba"
                },
                {
                    name: "chutesai/Devstral-Small-2505",
                    url: "https://chutes.ai/app/chute/6275d63c-ca84-56f2-81c1-93a4070c6348",
                    id: "6275d63c-ca84-56f2-81c1-93a4070c6348"
                }
            ];

            function ModelTester() {
                const [apiKey, setApiKey] = useState(localStorage.getItem('chutes_api_key') || '');
                const [testPrompt, setTestPrompt] = useState('What is the capital of France? Answer in one sentence.');
                const [modelResults, setModelResults] = useState({});
                const [testing, setTesting] = useState(false);

                useEffect(() => {
                    if (apiKey) {
                        localStorage.setItem('chutes_api_key', apiKey);
                    }
                }, [apiKey]);

                async function testModel(model) {
                    const startTime = performance.now();
                    
                    try {
                        const response = await fetch('https://api.chutes.ai/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model.id,
                                messages: [
                                    { role: 'user', content: testPrompt }
                                ],
                                temperature: 0.7,
                                max_tokens: 100
                            })
                        });

                        const endTime = performance.now();
                        const latency = Math.round(endTime - startTime);

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                        }

                        const data = await response.json();
                        const responseText = data.choices?.[0]?.message?.content || 'No response';

                        return {
                            status: 'success',
                            latency,
                            response: responseText,
                            error: null
                        };
                    } catch (error) {
                        const endTime = performance.now();
                        const latency = Math.round(endTime - startTime);
                        
                        return {
                            status: 'error',
                            latency,
                            response: '',
                            error: error.message
                        };
                    }
                }

                async function runTests() {
                    if (!apiKey.trim()) {
                        alert('Please enter your Chutes AI API key');
                        return;
                    }

                    if (!testPrompt.trim()) {
                        alert('Please enter a test prompt');
                        return;
                    }

                    setTesting(true);
                    setModelResults({});

                    // Test models sequentially to avoid rate limiting
                    for (const model of MODELS) {
                        setModelResults(prev => ({
                            ...prev,
                            [model.id]: { status: 'testing', latency: null, response: '', error: null }
                        }));

                        const result = await testModel(model);
                        
                        setModelResults(prev => ({
                            ...prev,
                            [model.id]: result
                        }));

                        // Small delay between requests to be respectful of the API
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    setTesting(false);
                }

                const completedTests = Object.values(modelResults).filter(r => r.status === 'success' || r.status === 'error').length;
                const successfulTests = Object.values(modelResults).filter(r => r.status === 'success').length;
                const failedTests = Object.values(modelResults).filter(r => r.status === 'error').length;
                const avgLatency = successfulTests > 0 
                    ? Math.round(Object.values(modelResults).filter(r => r.status === 'success').reduce((sum, r) => sum + r.latency, 0) / successfulTests)
                    : 0;

                return (
                    <div className="container">
                        <header>
                            <h1>üöÄ Chutes AI Model Latency Tester</h1>
                            <p className="subtitle">Test the top 10 models for response time and reliability</p>
                        </header>

                        <main>
                            <div className="controls">
                                <div className="control-group" style={{ flex: 2 }}>
                                    <label htmlFor="apiKey">Chutes AI API Key</label>
                                    <input
                                        id="apiKey"
                                        type="password"
                                        value={apiKey}
                                        onChange={(e) => setApiKey(e.target.value)}
                                        placeholder="Enter your API key..."
                                    />
                                </div>
                                
                                <div className="control-group" style={{ flex: 3 }}>
                                    <label htmlFor="testPrompt">Test Prompt</label>
                                    <textarea
                                        id="testPrompt"
                                        value={testPrompt}
                                        onChange={(e) => setTestPrompt(e.target.value)}
                                        placeholder="Enter your test prompt..."
                                    />
                                </div>

                                <button onClick={runTests} disabled={testing} style={{ alignSelf: 'flex-end' }}>
                                    {testing ? 'Testing...' : 'Run Tests'}
                                </button>
                            </div>

                            {completedTests > 0 && (
                                <div className="summary">
                                    <h2>Summary</h2>
                                    <div className="summary-stats">
                                        <div className="stat-item">
                                            <span className="stat-label">Completed</span>
                                            <span className="stat-value">{completedTests}/{MODELS.length}</span>
                                        </div>
                                        <div className="stat-item">
                                            <span className="stat-label">Successful</span>
                                            <span className="stat-value" style={{ color: 'var(--color-status-active)' }}>
                                                {successfulTests}
                                            </span>
                                        </div>
                                        <div className="stat-item">
                                            <span className="stat-label">Failed</span>
                                            <span className="stat-value" style={{ color: 'var(--color-status-inactive)' }}>
                                                {failedTests}
                                            </span>
                                        </div>
                                        <div className="stat-item">
                                            <span className="stat-label">Avg Latency</span>
                                            <span className="stat-value">{avgLatency}ms</span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="models-grid">
                                {MODELS.map((model) => {
                                    const result = modelResults[model.id] || { status: 'pending' };
                                    
                                    return (
                                        <div key={model.id} className={`model-card ${result.status}`}>
                                            <div className="model-header">
                                                <div className="model-name">{model.name}</div>
                                                <a href={model.url} target="_blank" rel="noopener noreferrer" className="model-link">
                                                    View ‚Üí
                                                </a>
                                            </div>

                                            <div className={`status-badge ${result.status}`}>
                                                {result.status === 'testing' && <span className="spinner"></span>}
                                                {result.status === 'pending' && '‚è≥ Pending'}
                                                {result.status === 'testing' && 'Testing...'}
                                                {result.status === 'success' && '‚úÖ Success'}
                                                {result.status === 'error' && '‚ùå Error'}
                                            </div>

                                            {result.latency !== null && (
                                                <div className="latency">{result.latency}ms</div>
                                            )}

                                            {result.error && (
                                                <div className="error-message">Error: {result.error}</div>
                                            )}

                                            {result.response && (
                                                <div className="response-box">{result.response}</div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </main>
                    </div>
                );
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<ModelTester />);
        </script>
    </body>
</html>

</code>

public\test.html:
<code>
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Chutes AI Model Latency Tester</title>
        
        <!-- Fonts -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Sansation:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
            rel="stylesheet"
        />
        
        <!-- Stylesheet -->
        <link rel="stylesheet" href="styles.css" />
        
        <style>
            .test-container {
                max-width: 1600px;
                margin: 0 auto;
                padding: 32px 20px;
            }

            .test-header {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 18px;
                padding: 32px;
                margin-bottom: 24px;
            }

            .test-header h1 {
                font-size: 2.3rem;
                font-weight: 500;
                color: var(--color-heading);
                margin-bottom: 12px;
            }

            .test-header p {
                font-size: 1.05rem;
                color: var(--color-text-muted);
            }

            .test-controls {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 14px;
                padding: 24px;
                margin-bottom: 24px;
            }

            .control-row {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
                flex-wrap: wrap;
            }

            .control-row:last-child {
                margin-bottom: 0;
            }

            .control-field {
                flex: 1;
                min-width: 250px;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .control-field label {
                font-size: 0.75rem;
                text-transform: uppercase;
                letter-spacing: 0.06em;
                color: var(--color-text-muted);
                font-weight: 700;
            }

            .control-field input,
            .control-field textarea {
                padding: 10px 14px;
                border-radius: 10px;
                border: 1px solid var(--color-border);
                background: var(--color-surface);
                color: var(--color-text);
                font-size: 0.95rem;
                font-family: inherit;
                transition: border-color 0.2s ease;
            }

            .control-field textarea {
                resize: vertical;
                min-height: 80px;
            }

            .control-field input:focus,
            .control-field textarea:focus {
                outline: none;
                border-color: var(--color-accent);
                box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.15);
            }

            .test-button {
                padding: 12px 28px;
                border-radius: 10px;
                border: none;
                background: var(--color-accent);
                color: var(--color-accent-contrast);
                font-weight: 600;
                font-size: 1rem;
                cursor: pointer;
                transition: transform 0.2s ease, background 0.2s ease;
                font-family: inherit;
                align-self: flex-end;
            }

            .test-button:hover:not(:disabled) {
                transform: translateY(-1px);
                background: var(--color-accent-hover);
            }

            .test-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .summary-section {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 14px;
                padding: 24px;
                margin-bottom: 24px;
            }

            .summary-section h2 {
                font-size: 1.3rem;
                font-weight: 600;
                color: var(--color-heading);
                margin-bottom: 16px;
            }

            .summary-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 16px;
            }

            .summary-stat {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .summary-stat-label {
                font-size: 0.8rem;
                color: var(--color-text-muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }

            .summary-stat-value {
                font-size: 1.4rem;
                font-weight: 700;
                color: var(--color-accent);
            }

            .models-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
                gap: 24px;
            }

            .model-test-card {
                background: var(--color-surface-alt);
                border: 1px solid var(--color-border);
                border-radius: 14px;
                padding: 20px;
                transition: border-color 0.3s ease;
            }

            .model-test-card.testing {
                border-color: var(--color-accent);
            }

            .model-test-card.success {
                border-color: var(--color-status-active);
            }

            .model-test-card.error {
                border-color: var(--color-status-inactive);
            }

            .model-card-header {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                margin-bottom: 16px;
                gap: 12px;
            }

            .model-card-name {
                font-size: 1.1rem;
                font-weight: 600;
                color: var(--color-heading);
                word-break: break-word;
            }

            .model-card-link {
                color: var(--color-accent);
                text-decoration: none;
                font-size: 0.85rem;
                white-space: nowrap;
            }

            .model-card-link:hover {
                color: var(--color-accent-hover);
            }

            .status-badge {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 6px 12px;
                border-radius: 999px;
                font-size: 0.85rem;
                font-weight: 600;
                margin-bottom: 12px;
            }

            .status-badge.pending {
                background: rgba(251, 191, 36, 0.2);
                color: #fbbf24;
            }

            .status-badge.testing {
                background: rgba(96, 165, 250, 0.2);
                color: var(--color-accent);
            }

            .status-badge.success {
                background: rgba(52, 211, 153, 0.2);
                color: var(--color-status-active);
            }

            .status-badge.error {
                background: rgba(248, 113, 113, 0.2);
                color: var(--color-status-inactive);
            }

            .latency-display {
                font-size: 1.5rem;
                font-weight: 700;
                color: var(--color-accent);
                margin-bottom: 12px;
            }

            .response-container {
                background: var(--color-surface);
                border: 1px solid var(--color-border);
                border-radius: 8px;
                padding: 12px;
                max-height: 200px;
                overflow-y: auto;
                font-size: 0.9rem;
                color: var(--color-text-muted);
                white-space: pre-wrap;
                word-break: break-word;
                min-height: 60px;
            }

            .response-container:empty::before {
                content: 'Waiting for response...';
                color: var(--color-text-muted);
                opacity: 0.5;
            }

            .error-text {
                color: var(--color-status-inactive);
                font-size: 0.85rem;
                margin-top: 8px;
            }

            .spinner {
                display: inline-block;
                width: 16px;
                height: 16px;
                border: 2px solid rgba(148, 163, 184, 0.2);
                border-top: 2px solid var(--color-accent);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            @media (max-width: 768px) {
                .models-grid {
                    grid-template-columns: 1fr;
                }
                
                .test-header h1 {
                    font-size: 1.8rem;
                }

                .control-row {
                    flex-direction: column;
                }

                .control-field {
                    min-width: 100%;
                }
            }
        </style>
    </head>
    <body data-theme="dark-default">
        <div id="root"></div>
        <script type="module" src="/test.jsx"></script>
    </body>
</html>

</code>

public\test.jsx:
<code>
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';

function ModelTester() {
    const [testPrompt, setTestPrompt] = useState('What is the capital of France? Answer in one sentence.');
    const [modelResults, setModelResults] = useState({});
    const [testing, setTesting] = useState(false);
    const [allModels, setAllModels] = useState([]);
    const [selectedModels, setSelectedModels] = useState([]);
    const [loading, setLoading] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');

    // Fetch models on load
    useEffect(() => {
        fetchModels();
    }, []);

    async function fetchModels() {
        try {
            setLoading(true);
            const response = await fetch('/api/models?limit=1000&include_public=true');
            const data = await response.json();
            
            // Only show text generation models (VLLM, TGI templates)
            const textModels = (data.items || [])
                .filter(m => m.standard_template === 'vllm' || m.standard_template === 'tgi')
                .filter(m => m.name) // Must have a name
                .map(m => ({
                    name: m.name,
                    id: m.name,
                    url: m.chute_id ? `https://chutes.ai/app/chute/${m.chute_id}` : '#',
                    invocations: m.invocation_count || 0,
                    hot: m.hot || false
                }))
                .sort((a, b) => b.invocations - a.invocations); // Sort by popularity
            
            setAllModels(textModels);
            // Auto-select top 10 by default
            setSelectedModels(textModels.slice(0, 10).map(m => m.id));
            setLoading(false);
        } catch (error) {
            console.error('Error fetching models:', error);
            setLoading(false);
        }
    }

    async function testModel(model) {
        const startTime = performance.now();
        
        try {
            const response = await fetch('/api/test-model', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: model.id,
                    prompt: testPrompt,
                    temperature: 0.7,
                    max_tokens: 100
                })
            });

            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `HTTP ${response.status}`);
            }

            const data = await response.json();
            const responseText = data.choices?.[0]?.message?.content?.trim() || '';

            return {
                status: 'success',
                latency,
                response: responseText || '(Empty response)',
                error: null
            };
        } catch (error) {
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);
            
            return {
                status: 'error',
                latency,
                response: '',
                error: error.message
            };
        }
    }

    async function runTests() {
        if (!testPrompt.trim()) {
            alert('Please enter a test prompt');
            return;
        }

        if (selectedModels.length === 0) {
            alert('Please select at least one model to test');
            return;
        }

        setTesting(true);
        setModelResults({});

        const modelsToTest = allModels.filter(m => selectedModels.includes(m.id));

        // Test models sequentially to avoid rate limiting
        for (const model of modelsToTest) {
            setModelResults(prev => ({
                ...prev,
                [model.id]: { status: 'testing', latency: null, response: '', error: null }
            }));

            const result = await testModel(model);
            
            setModelResults(prev => ({
                ...prev,
                [model.id]: result
            }));

            // Small delay between requests
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        setTesting(false);
    }

    function toggleModel(modelId) {
        setSelectedModels(prev => {
            if (prev.includes(modelId)) {
                return prev.filter(id => id !== modelId);
            } else {
                return [...prev, modelId];
            }
        });
    }

    function selectTop(count) {
        setSelectedModels(allModels.slice(0, count).map(m => m.id));
    }

    function clearSelection() {
        setSelectedModels([]);
    }

    const filteredModels = allModels.filter(m => 
        m.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const modelsToDisplay = allModels.filter(m => selectedModels.includes(m.id));

    const completedTests = Object.values(modelResults).filter(r => r.status === 'success' || r.status === 'error').length;
    const successfulTests = Object.values(modelResults).filter(r => r.status === 'success').length;
    const failedTests = Object.values(modelResults).filter(r => r.status === 'error').length;
    const avgLatency = successfulTests > 0 
        ? Math.round(Object.values(modelResults).filter(r => r.status === 'success').reduce((sum, r) => sum + r.latency, 0) / successfulTests)
        : 0;

    if (loading) {
        return (
            <div className="test-container">
                <div className="test-header">
                    <h1>üöÄ Chutes AI Model Latency Tester</h1>
                    <p>Loading models...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="test-container">
            <div className="test-header">
                <h1>üöÄ Chutes AI Model Latency Tester</h1>
                <p>Select models to test for response time and reliability</p>
            </div>

            <div className="test-controls">
                <div className="control-row">
                    <div className="control-field" style={{ flex: 1 }}>
                        <label htmlFor="modelSearch">Search Models ({allModels.length} available)</label>
                        <input
                            id="modelSearch"
                            type="text"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            placeholder="Search by name..."
                        />
                    </div>
                    <div className="control-field" style={{ flex: 0, minWidth: 'auto' }}>
                        <label>&nbsp;</label>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <button onClick={() => selectTop(10)} className="test-button" style={{ fontSize: '0.85rem', padding: '8px 16px' }}>
                                Top 10
                            </button>
                            <button onClick={() => selectTop(20)} className="test-button" style={{ fontSize: '0.85rem', padding: '8px 16px' }}>
                                Top 20
                            </button>
                            <button onClick={clearSelection} className="test-button" style={{ fontSize: '0.85rem', padding: '8px 16px' }}>
                                Clear
                            </button>
                        </div>
                    </div>
                </div>

                <div className="control-row">
                    <div className="control-field">
                        <label>Selected Models ({selectedModels.length})</label>
                        <div style={{ 
                            maxHeight: '150px', 
                            overflowY: 'auto', 
                            padding: '8px',
                            background: 'var(--color-surface)',
                            border: '1px solid var(--color-border)',
                            borderRadius: '8px'
                        }}>
                            {filteredModels.length === 0 ? (
                                <div style={{ color: 'var(--color-text-muted)', fontSize: '0.9rem' }}>
                                    No models found
                                </div>
                            ) : (
                                filteredModels.slice(0, 50).map(model => (
                                    <label 
                                        key={model.id}
                                        style={{ 
                                            display: 'flex', 
                                            alignItems: 'center', 
                                            gap: '8px',
                                            padding: '4px',
                                            cursor: 'pointer',
                                            fontSize: '0.9rem'
                                        }}
                                    >
                                        <input
                                            type="checkbox"
                                            checked={selectedModels.includes(model.id)}
                                            onChange={() => toggleModel(model.id)}
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <span>{model.name}</span>
                                        {model.hot && <span style={{ fontSize: '0.7rem' }}>üî•</span>}
                                    </label>
                                ))
                            )}
                            {filteredModels.length > 50 && (
                                <div style={{ color: 'var(--color-text-muted)', fontSize: '0.85rem', marginTop: '8px' }}>
                                    Showing 50 of {filteredModels.length} models. Use search to narrow down.
                                </div>
                            )}
                        </div>
                    </div>
                </div>
                
                <div className="control-row">
                    <div className="control-field" style={{ flex: 2 }}>
                        <label htmlFor="testPrompt">Test Prompt</label>
                        <textarea
                            id="testPrompt"
                            value={testPrompt}
                            onChange={(e) => setTestPrompt(e.target.value)}
                            placeholder="Enter your test prompt..."
                        />
                    </div>
                </div>
                
                <div className="control-row">
                    <button onClick={runTests} disabled={testing || selectedModels.length === 0} className="test-button">
                        {testing ? `Testing ${completedTests}/${selectedModels.length}...` : `Run Tests (${selectedModels.length} models)`}
                    </button>
                </div>
            </div>

            {completedTests > 0 && (
                <div className="summary-section">
                    <h2>Summary</h2>
                    <div className="summary-grid">
                        <div className="summary-stat">
                            <span className="summary-stat-label">Completed</span>
                            <span className="summary-stat-value">{completedTests}/{MODELS.length}</span>
                        </div>
                        <div className="summary-stat">
                            <span className="summary-stat-label">Successful</span>
                            <span className="summary-stat-value" style={{ color: 'var(--color-status-active)' }}>
                                {successfulTests}
                            </span>
                        </div>
                        <div className="summary-stat">
                            <span className="summary-stat-label">Failed</span>
                            <span className="summary-stat-value" style={{ color: 'var(--color-status-inactive)' }}>
                                {failedTests}
                            </span>
                        </div>
                        <div className="summary-stat">
                            <span className="summary-stat-label">Avg Latency</span>
                            <span className="summary-stat-value">{avgLatency}ms</span>
                        </div>
                    </div>
                </div>
            )}

            <div className="models-grid">
                {allModels.filter(m => selectedModels.includes(m.id)).map((model) => {
                    const result = modelResults[model.id] || { status: 'pending' };
                    
                    return (
                        <div key={model.id} className={`model-test-card ${result.status}`}>
                            <div className="model-card-header">
                                <div className="model-card-name">{model.name}</div>
                                <div className="model-card-meta">
                                    {model.hot && <span style={{ fontSize: '0.8rem' }}>üî•</span>}
                                    {model.template_name && (
                                        <span style={{ fontSize: '0.75rem', color: 'var(--color-text-muted)' }}>
                                            {model.template_name}
                                        </span>
                                    )}
                                </div>
                            </div>

                            <div className={`status-badge ${result.status}`}>
                                {result.status === 'testing' && <span className="spinner"></span>}
                                {result.status === 'pending' && '‚è≥ Pending'}
                                {result.status === 'testing' && 'Testing...'}
                                {result.status === 'success' && '‚úÖ Success'}
                                {result.status === 'error' && '‚ùå Error'}
                            </div>

                            {result.latency !== null && (
                                <div className="latency-display">{result.latency}ms</div>
                            )}

                            {result.error && (
                                <div className="error-text">Error: {result.error}</div>
                            )}

                            {result.response && (
                                <div className="response-container">{result.response}</div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ModelTester />);

</code>

.dockerignore:
<code>
node_modules
npm-debug.log
.git
.gitignore
README.md
.env.example
.vscode
*.md

</code>

.env.example:
<code>
# Chutes API Configuration
CHUTES_API_KEY=your-api-key-here
PORT=3000

# Optional parameters
CHUTES_BASE_URL=https://api.chutes.ai

</code>

Dockerfile:
<code>
# Use official Node.js LTS image (supports ARM64)
FROM node:20-bookworm-slim

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies (including devDependencies for build)
RUN npm install

# Copy application files
COPY . .

# Build with Vite
RUN npm run build

# Remove devDependencies to reduce image size
RUN npm prune --production

# Create cache directory
RUN mkdir -p /app/cache

# Expose port
EXPOSE 3888

# Set production environment
ENV NODE_ENV=production

# Start the application
CMD ["node", "server.js"]

</code>

export-data.js:
<code>
#!/usr/bin/env node

/**
 * Raw Data Export & Analysis Tool
 * 
 * This utility helps extract and analyze raw data from the Chutes Models app
 * Usage: node export-data.js [options]
 * 
 * Options:
 *   --all              Export everything (default)
 *   --chutes           Export only Chutes API data
 *   --v1               Export only V1 API data
 *   --analysis         Show merge analysis only
 *   --format [json|csv|md]  Output format (default: json)
 *   --output [file]    Save to file (default: stdout)
 */

const fs = require('fs').promises;
const path = require('path');
const http = require('http');

const BASE_URL = process.env.BASE_URL || 'http://localhost:3888';
const CACHE_DIR = path.join(__dirname, 'cache');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
    all: true,
    format: 'json',
    output: null
};

args.forEach(arg => {
    if (arg === '--all') options.all = true;
    if (arg === '--chutes') options.all = false;
    if (arg === '--v1') options.all = false;
    if (arg === '--analysis') options.all = false;
    if (arg.startsWith('--format')) options.format = arg.split('=')[1] || 'json';
    if (arg.startsWith('--output')) options.output = arg.split('=')[1];
});

/**
 * Fetch data from local endpoint
 */
async function fetchExportData() {
    return new Promise((resolve, reject) => {
        const url = new URL('/api/export/data', BASE_URL);
        const client = url.protocol === 'https:' ? require('https') : http;
        
        client.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(new Error(`Failed to parse response: ${e.message}`));
                }
            });
        }).on('error', reject);
    });
}

/**
 * Read cache files directly
 */
async function readCacheFiles() {
    const data = { chutesApi: null, v1Api: null };
    
    try {
        // Read Chutes API cache
        const chutesCacheFile = path.join(CACHE_DIR, 'models_p0_l1000_tnull_nnull_pubtrue.json');
        const chutesContent = await fs.readFile(chutesCacheFile, 'utf8');
        const chutesData = JSON.parse(chutesContent);
        data.chutesApi = {
            source: 'https://api.chutes.ai/chutes/',
            modelCount: chutesData.data?.items?.length || 0,
            data: chutesData.data
        };
    } catch (err) {
        console.warn('‚ö†Ô∏è  Could not read Chutes API cache:', err.message);
    }
    
    try {
        // Read V1 API cache
        const v1CacheFile = path.join(CACHE_DIR, 'v1_models_all.json');
        const v1Content = await fs.readFile(v1CacheFile, 'utf8');
        const v1Data = JSON.parse(v1Content);
        data.v1Api = {
            source: 'https://llm.chutes.ai/v1/models',
            modelCount: v1Data.data?.data?.length || 0,
            data: v1Data.data
        };
    } catch (err) {
        console.warn('‚ö†Ô∏è  Could not read V1 API cache:', err.message);
    }
    
    return data;
}

/**
 * Format data as CSV
 */
function formatAsCSV(exportData) {
    let csv = '';
    
    if (exportData.sources.chutesApi?.data?.items) {
        csv += '# Chutes API Models\n';
        csv += 'name,chute_id,template,pricing_input_usd,pricing_output_usd,instances_active,gpus\n';
        
        exportData.sources.chutesApi.data.items.forEach(model => {
            const inputPrice = model.current_estimated_price?.per_million_tokens?.input?.usd || 'N/A';
            const outputPrice = model.current_estimated_price?.per_million_tokens?.output?.usd || 'N/A';
            const activeInstances = model.instances?.filter(i => i.active).length || 0;
            const gpus = model.supported_gpus?.join(';') || 'N/A';
            
            csv += `"${model.name}","${model.chute_id}","${model.standard_template}","${inputPrice}","${outputPrice}","${activeInstances}","${gpus}"\n`;
        });
    }
    
    csv += '\n# V1 Models (with modalities)\n';
    if (exportData.sources.v1Api?.data?.data) {
        csv += 'id,quantization,context_length,max_output_length,input_modalities,output_modalities,supported_features\n';
        
        exportData.sources.v1Api.data.data.forEach(model => {
            const inputMod = model.input_modalities?.join(';') || 'N/A';
            const outputMod = model.output_modalities?.join(';') || 'N/A';
            const features = model.supported_features?.join(';') || 'N/A';
            
            csv += `"${model.id}","${model.quantization}","${model.context_length}","${model.max_output_length}","${inputMod}","${outputMod}","${features}"\n`;
        });
    }
    
    return csv;
}

/**
 * Format data as Markdown
 */
function formatAsMarkdown(exportData) {
    let md = '# Chutes Models Export\n\n';
    md += `Generated: ${new Date().toISOString()}\n\n`;
    
    if (exportData.sources.mergeAnalysis) {
        const analysis = exportData.sources.mergeAnalysis;
        md += '## Merge Analysis\n\n';
        md += `- **Total in Chutes API:** ${analysis.totalInChutesApi}\n`;
        md += `- **Total in V1 API:** ${analysis.totalInV1Api}\n`;
        md += `- **Matched:** ${analysis.matched} (${analysis.matchPercentage})\n\n`;
        
        if (analysis.onlyInChutesApi.length > 0) {
            md += `### Only in Chutes API (${analysis.onlyInChutesApi.length}):\n\n`;
            analysis.onlyInChutesApi.forEach(name => {
                md += `- \`${name}\`\n`;
            });
            md += '\n';
        }
        
        if (analysis.onlyInV1Api.length > 0) {
            md += `### Only in V1 API (${analysis.onlyInV1Api.length}):\n\n`;
            analysis.onlyInV1Api.slice(0, 20).forEach(id => {
                md += `- \`${id}\`\n`;
            });
            if (analysis.onlyInV1Api.length > 20) {
                md += `- ... and ${analysis.onlyInV1Api.length - 20} more\n`;
            }
            md += '\n';
        }
    }
    
    if (exportData.sources.chutesApi?.data?.items) {
        md += `## Chutes API Models (${exportData.sources.chutesApi.data.items.length})\n\n`;
        md += '| Model | Template | Input Price | Output Price | Instances | GPUs |\n';
        md += '|-------|----------|-------------|--------------|-----------|------|\n';
        
        exportData.sources.chutesApi.data.items.slice(0, 50).forEach(model => {
            const inputPrice = model.current_estimated_price?.per_million_tokens?.input?.usd || 'N/A';
            const outputPrice = model.current_estimated_price?.per_million_tokens?.output?.usd || 'N/A';
            const activeInstances = model.instances?.filter(i => i.active).length || 0;
            const gpus = model.supported_gpus?.join(', ') || 'N/A';
            
            md += `| ${model.name} | ${model.standard_template} | $${inputPrice} | $${outputPrice} | ${activeInstances} | ${gpus} |\n`;
        });
        
        if (exportData.sources.chutesApi.data.items.length > 50) {
            md += `\n... and ${exportData.sources.chutesApi.data.items.length - 50} more models\n`;
        }
    }
    
    return md;
}

/**
 * Main execution
 */
async function main() {
    try {
        console.log('üìä Chutes Models Export Tool\n');
        
        let exportData;
        
        // Try to fetch from API first
        try {
            console.log('üåê Fetching from API endpoint...');
            exportData = await fetchExportData();
            console.log('‚úÖ Data fetched from API\n');
        } catch (err) {
            console.log('‚ö†Ô∏è  API not available, reading cache files directly...');
            const cacheData = await readCacheFiles();
            exportData = {
                timestamp: new Date().toISOString(),
                sources: cacheData
            };
            console.log('‚úÖ Data read from cache\n');
        }
        
        // Format output
        let output = '';
        if (options.format === 'csv') {
            output = formatAsCSV(exportData);
        } else if (options.format === 'md') {
            output = formatAsMarkdown(exportData);
        } else {
            output = JSON.stringify(exportData, null, 2);
        }
        
        // Write output
        if (options.output) {
            await fs.writeFile(options.output, output, 'utf8');
            console.log(`‚úÖ Export saved to: ${options.output}`);
        } else {
            console.log(output);
        }
        
    } catch (error) {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
    }
}

main();

</code>

nodemon.json:
<code>
{
  "ignore": [
    "cache/*",
    "node_modules/*",
    "dist/*",
    "*.log"
  ],
  "ext": "js,json",
  "delay": 1000
}
</code>

package.json:
<code>
{
  "name": "chutes-models-enhanced",
  "version": "1.0.0",
  "description": "Enhanced Chutes AI Model Explorer with complete API access",
  "main": "server.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "start": "node server.js",
    "server": "nodemon --config nodemon.json server.js",
    "dev:all": "concurrently \"npm run server\" \"npm run dev\""
  },
  "keywords": [
    "chutes",
    "ai",
    "models",
    "api"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "node-fetch": "^2.7.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "concurrently": "^8.2.2",
    "nodemon": "^3.0.1",
    "vite": "^7.1.11"
  }
}

</code>

server.js:
<code>
require('dotenv').config();
const express = require('express');
const fetch = require('node-fetch');
const path = require('path');
const cors = require('cors');
const fs = require('fs').promises;

const app = express();
const PORT = process.env.PORT || 3888;
const CHUTES_API_KEY = process.env.CHUTES_API_KEY;
const CHUTES_BASE_URL = process.env.CHUTES_BASE_URL || 'https://api.chutes.ai';

// Cache configuration - configurable via environment variable
const CACHE_DIR = path.join(__dirname, 'cache');
const CACHE_DURATION_MINUTES = parseInt(process.env.CACHE_DURATION_MINUTES || '10', 10);
const CACHE_DURATION = CACHE_DURATION_MINUTES * 60 * 1000; // Convert minutes to milliseconds

// In-memory cache tracker
const cacheTracker = new Map();

// Middleware
app.use(cors());
// Increase JSON body size limit to handle large token files (up to 2MB)
app.use(express.json({ limit: '2mb' }));
// Also handle text payloads with increased limit
app.use(express.text({ limit: '2mb' }));

// Serve static files from dist in production, public in development
const staticDir = process.env.NODE_ENV === 'production' ? 'dist' : 'public';
app.use(express.static(staticDir));
console.log(`üìÇ Serving static files from: ${staticDir}`);

// Initialize cache directory
async function initCache() {
    try {
        await fs.mkdir(CACHE_DIR, { recursive: true });
        console.log('‚úÖ Cache directory initialized');
    } catch (err) {
        console.error('Failed to create cache directory:', err);
    }
}

// Generate cache key from query parameters
function getCacheKey(params) {
    const { page = 0, limit = 100, template = '', name = '', include_public = true } = params;
    return `models_p${page}_l${limit}_t${template}_n${name}_pub${include_public}.json`;
}

// Get cache file path with timestamp
function getCacheFilePath(cacheKey) {
    return path.join(CACHE_DIR, cacheKey);
}

// Check if cache is valid
async function getCachedData(cacheKey) {
    try {
        const cacheFile = getCacheFilePath(cacheKey);
        
        // Check in-memory tracker first
        const trackerEntry = cacheTracker.get(cacheKey);
        if (trackerEntry) {
            const age = Date.now() - trackerEntry.timestamp;
            if (age < CACHE_DURATION) {
                console.log(`üì¶ Using in-memory cache for ${cacheKey} (age: ${Math.round(age / 1000)}s)`);
                return trackerEntry.data;
            } else {
                console.log(`‚è∞ Cache expired for ${cacheKey} (age: ${Math.round(age / 1000)}s)`);
                cacheTracker.delete(cacheKey);
            }
        }

        // Try to read from disk
        const fileContent = await fs.readFile(cacheFile, 'utf8');
        const cached = JSON.parse(fileContent);
        
        const age = Date.now() - cached.timestamp;
        if (age < CACHE_DURATION) {
            console.log(`üíæ Using disk cache for ${cacheKey} (age: ${Math.round(age / 1000)}s)`);
            // Store in memory for faster access next time
            cacheTracker.set(cacheKey, {
                timestamp: cached.timestamp,
                data: cached.data
            });
            return cached.data;
        } else {
            console.log(`‚è∞ Disk cache expired for ${cacheKey} (age: ${Math.round(age / 1000)}s)`);
            // Delete expired cache file
            await fs.unlink(cacheFile).catch(() => {});
        }
    } catch (err) {
        // Cache miss or error reading cache
        if (err.code !== 'ENOENT') {
            console.log('Cache read error:', err.message);
        }
    }
    return null;
}

// Save data to cache
async function setCachedData(cacheKey, data) {
    try {
        const timestamp = Date.now();
        const cacheFile = getCacheFilePath(cacheKey);
        
        // Save to memory
        cacheTracker.set(cacheKey, { timestamp, data });
        
        // Save to disk
        await fs.writeFile(
            cacheFile,
            JSON.stringify({ timestamp, data }, null, 2),
            'utf8'
        );
        
        console.log(`üíæ Cached data saved for ${cacheKey}`);
    } catch (err) {
        console.error('Failed to save cache:', err);
    }
}

// Note: Cache cleanup disabled - files are kept permanently for offline access
// Cache files will show age to users so they know how old the data is
async function cleanupCache() {
    // Cleanup disabled - cache files are kept indefinitely
    // This allows the app to work offline or when API is down
    console.log('üíæ Cache cleanup disabled - files kept for offline access');
}

// Check if API key is configured
if (!CHUTES_API_KEY) {
    console.error('ERROR: CHUTES_API_KEY is not set in .env file');
    console.error('Please create a .env file with your API key');
    process.exit(1);
}

// Token test results storage
const TOKEN_TEST_RESULTS_FILE = path.join(__dirname, 'cache', 'token_test_results.json');

// Rate limiting storage
const RATE_LIMITS_FILE = path.join(__dirname, 'cache', 'rate_limits.json');

// Load token test results
async function loadTokenTestResults() {
    try {
        const content = await fs.readFile(TOKEN_TEST_RESULTS_FILE, 'utf8');
        return JSON.parse(content);
    } catch (err) {
        // File doesn't exist yet, return empty object
        return {};
    }
}

// Save token test results
async function saveTokenTestResults(results) {
    try {
        await fs.writeFile(TOKEN_TEST_RESULTS_FILE, JSON.stringify(results, null, 2), 'utf8');
        console.log('üíæ Token test results saved');
    } catch (err) {
        console.error('Failed to save token test results:', err);
    }
}

// Load rate limits
async function loadRateLimits() {
    try {
        const content = await fs.readFile(RATE_LIMITS_FILE, 'utf8');
        const data = JSON.parse(content);
        
        // Check if we need to reset daily counters (midnight UTC)
        const now = new Date();
        const lastReset = new Date(data.lastDailyReset || 0);
        const resetNeeded = now.getUTCDate() !== lastReset.getUTCDate() || 
                           now.getUTCMonth() !== lastReset.getUTCMonth() || 
                           now.getUTCFullYear() !== lastReset.getUTCFullYear();
        
        if (resetNeeded) {
            console.log('üåÖ Resetting daily rate limits (midnight UTC)');
            data.dailyTokenTests = 0;
            data.dailyLatencyTests = 0;
            data.lastDailyReset = now.toISOString();
        }
        
        return data;
    } catch (err) {
        // File doesn't exist yet, return default structure
        const now = new Date();
        return {
            weeklyTokenTests: {}, // modelName -> lastTestTimestamp
            dailyTokenTests: 0,
            dailyLatencyTests: 0,
            lastDailyReset: now.toISOString()
        };
    }
}

// Save rate limits
async function saveRateLimits(limits) {
    try {
        await fs.writeFile(RATE_LIMITS_FILE, JSON.stringify(limits, null, 2), 'utf8');
        console.log('üíæ Rate limits saved');
    } catch (err) {
        console.error('Failed to save rate limits:', err);
    }
}

// Check if token test is allowed for a model
async function checkTokenTestLimits(modelName) {
    const limits = await loadRateLimits();
    const now = new Date();
    
    // Check weekly limit per model
    const lastTest = limits.weeklyTokenTests[modelName];
    if (lastTest) {
        const lastTestDate = new Date(lastTest);
        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        if (lastTestDate > weekAgo) {
            return { allowed: false, reason: 'Model was tested within the last week' };
        }
    }
    
    // Check daily limit
    if (limits.dailyTokenTests >= 10) {
        return { allowed: false, reason: 'Daily token test limit (10) reached' };
    }
    
    return { allowed: true };
}

// Check if latency test is allowed
async function checkLatencyTestLimits() {
    const limits = await loadRateLimits();
    
    // Check daily limit
    if (limits.dailyLatencyTests >= 10) {
        return { allowed: false, reason: 'Daily latency test limit (10) reached' };
    }
    
    return { allowed: true };
}

// Update rate limits after successful test
async function updateRateLimits(testType, modelName = null) {
    const limits = await loadRateLimits();
    
    if (testType === 'token') {
        limits.dailyTokenTests++;
        if (modelName) {
            limits.weeklyTokenTests[modelName] = new Date().toISOString();
        }
    } else if (testType === 'latency') {
        limits.dailyLatencyTests++;
    }
    
    await saveRateLimits(limits);
}

// Initialize
initCache();

// API endpoint to fetch models (with caching)
app.get('/api/models', async (req, res) => {
    try {
        const {
            page = 0,
            limit = 100,
            include_public = true,
            template = null,
            name = null,
            include_schemas = true
        } = req.query;

        // Generate cache key based on query parameters
        const cacheKey = getCacheKey({ page, limit, template, name, include_public });

        // Try to get cached data
        const cachedData = await getCachedData(cacheKey);
        if (cachedData) {
            // Add cache info to response headers
            const cacheTimestamp = cacheTracker.get(cacheKey)?.timestamp || Date.now();
            const cacheAge = Math.round((Date.now() - cacheTimestamp) / 1000);
            const cacheDate = new Date(cacheTimestamp).toISOString();
            
            res.set('X-Cache', 'HIT');
            res.set('X-Cache-Age', cacheAge);
            res.set('X-Cache-Date', cacheDate);
            return res.json(cachedData);
        }

        // Cache miss - fetch from API
        console.log(`üåê Fetching fresh data from API for ${cacheKey}`);

        // Build query parameters
        const params = new URLSearchParams();
        params.append('page', page);
        params.append('limit', limit);
        params.append('include_public', include_public);
        if (include_schemas) params.append('include_schemas', 'true');
        if (template) params.append('template', template);
        if (name) params.append('name', name);

        const url = `${CHUTES_BASE_URL}/chutes/?${params.toString()}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${CHUTES_API_KEY}`
            }
        });

        if (!response.ok) {
            throw new Error(`Chutes API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        
        console.log(`‚úÖ Successfully fetched ${data.items?.length || 0} models from API`);
        
        // Cache the response
        await setCachedData(cacheKey, data);

        // Add cache info to response headers
        res.set('X-Cache', 'MISS');
        res.set('X-Cache-Duration', CACHE_DURATION / 1000);
        
        res.json(data);
    } catch (error) {
        console.error('Error fetching models:', error);
        res.status(500).json({
            error: 'Failed to fetch models',
            message: error.message
        });
    }
});

// API endpoint to fetch additional model info from /v1/models (for modalities)
app.get('/api/models/v1/all', async (req, res) => {
    try {
        const cacheKey = 'v1_models_all.json';
        
        // Try to get cached data
        const cachedData = await getCachedData(cacheKey);
        if (cachedData) {
            const cacheTimestamp = cacheTracker.get(cacheKey)?.timestamp || Date.now();
            const cacheAge = Math.round((Date.now() - cacheTimestamp) / 1000);
            const cacheDate = new Date(cacheTimestamp).toISOString();
            
            res.set('X-Cache', 'HIT');
            res.set('X-Cache-Age', cacheAge);
            res.set('X-Cache-Date', cacheDate);
            return res.json(cachedData);
        }

        console.log('üåê Fetching /v1/models data (for modalities info)');
        
        const url = 'https://llm.chutes.ai/v1/models';
        const response = await fetch(url);

        if (!response.ok) {
            throw new Error(`V1 API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        
        // Cache the response
        await setCachedData(cacheKey, data);
        
        res.set('X-Cache', 'MISS');
        res.json(data);
    } catch (error) {
        console.error('Error fetching v1 models:', error);
        res.status(500).json({
            error: 'Failed to fetch v1 models',
            message: error.message
        });
    }
});

// API endpoint to fetch a specific model
app.get('/api/models/:chute_id', async (req, res) => {
    try {
        const { chute_id } = req.params;
        const url = `${CHUTES_BASE_URL}/chutes/${chute_id}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${CHUTES_API_KEY}`
            }
        });

        if (!response.ok) {
            throw new Error(`Chutes API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        res.json(data);
    } catch (error) {
        console.error('Error fetching model:', error);
        res.status(500).json({
            error: 'Failed to fetch model',
            message: error.message
        });
    }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({
        status: 'ok',
        apiKeyConfigured: !!CHUTES_API_KEY,
        baseUrl: CHUTES_BASE_URL,
        cache: {
            duration: `${CACHE_DURATION / 1000} seconds`,
            inMemoryEntries: cacheTracker.size
        }
    });
});

// Cache status endpoint
app.get('/api/cache/status', async (req, res) => {
    try {
        const files = await fs.readdir(CACHE_DIR);
        const cacheFiles = files.filter(f => f.endsWith('.json'));
        
        const cacheInfo = [];
        for (const file of cacheFiles) {
            try {
                const filePath = path.join(CACHE_DIR, file);
                const content = await fs.readFile(filePath, 'utf8');
                const cached = JSON.parse(content);
                const age = Date.now() - cached.timestamp;
                
                cacheInfo.push({
                    key: file,
                    age: Math.round(age / 1000),
                    valid: age < CACHE_DURATION,
                    itemCount: cached.data?.items?.length || 0
                });
            } catch (err) {
                // Skip invalid files
            }
        }

        res.json({
            cacheDuration: CACHE_DURATION / 1000,
            inMemoryEntries: cacheTracker.size,
            diskFiles: cacheInfo.length,
            entries: cacheInfo
        });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// API endpoint to export raw data from all sources
app.get('/api/export/data', async (req, res) => {
    try {
        const exportData = {
            timestamp: new Date().toISOString(),
            sources: {
                chutesApi: null,
                v1Api: null,
                mergeAnalysis: null
            }
        };

        // Get Chutes API data
        try {
            const chutesCache = await getCachedData('models_p0_l1000_tnull_nnull_pubtrue.json');
            if (chutesCache) {
                exportData.sources.chutesApi = {
                    source: 'https://api.chutes.ai/chutes/',
                    requiresAuth: true,
                    modelCount: chutesCache.items?.length || 0,
                    data: chutesCache
                };
            }
        } catch (err) {
            console.warn('Could not get Chutes API cache:', err.message);
        }

        // Get V1 API data
        try {
            const v1Cache = await getCachedData('v1_models_all.json');
            if (v1Cache) {
                exportData.sources.v1Api = {
                    source: 'https://llm.chutes.ai/v1/models',
                    requiresAuth: false,
                    modelCount: v1Cache.data?.length || 0,
                    data: v1Cache
                };
            }
        } catch (err) {
            console.warn('Could not get V1 API cache:', err.message);
        }

        // Generate merge analysis
        if (exportData.sources.chutesApi && exportData.sources.v1Api) {
            const chutesModels = exportData.sources.chutesApi.data.items || [];
            const v1Models = exportData.sources.v1Api.data.data || [];
            
            const chutesNames = new Set(chutesModels.map(m => m.name));
            const v1Names = new Set(v1Models.map(m => m.id));
            
            const matched = chutesModels.filter(m => v1Names.has(m.name)).length;
            const onlyInChutes = chutesModels.filter(m => !v1Names.has(m.name)).map(m => m.name);
            const onlyInV1 = v1Models.filter(m => !chutesNames.has(m.id)).map(m => m.id);
            
            exportData.sources.mergeAnalysis = {
                totalInChutesApi: chutesModels.length,
                totalInV1Api: v1Models.length,
                matched: matched,
                matchPercentage: ((matched / Math.min(chutesModels.length, v1Models.length)) * 100).toFixed(2) + '%',
                onlyInChutesApi: onlyInChutes,
                onlyInV1Api: onlyInV1,
                dataGaps: {
                    chutesApiMissing: ['modalities', 'context_length', 'max_output_length', 'quantization', 'supported_features'],
                    v1ApiMissing: ['pricing_organization_specific', 'instances', 'deployment_status', 'gpu_allocation', 'invocation_count']
                }
            };
        }

        // Set response headers for file download
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="chutes-models-export-${Date.now()}.json"`);
        
        res.json(exportData);
    } catch (error) {
        console.error('Error exporting data:', error);
        res.status(500).json({
            error: 'Failed to export data',
            message: error.message
        });
    }
});

// API endpoint to get token test results
app.get('/api/token-test-results', async (req, res) => {
    try {
        const results = await loadTokenTestResults();
        res.json(results);
    } catch (error) {
        console.error('Error loading token test results:', error);
        res.status(500).json({
            error: 'Failed to load token test results',
            message: error.message
        });
    }
});

// API endpoint to save token test result
app.post('/api/token-test-results', async (req, res) => {
    try {
        const { modelName, result } = req.body;
        
        if (!modelName || !result) {
            return res.status(400).json({ error: 'Model name and result are required' });
        }

        // Load existing results
        const allResults = await loadTokenTestResults();
        
        // Add/update result for this model
        allResults[modelName] = {
            ...result,
            lastTested: new Date().toISOString()
        };
        
        // Save updated results
        await saveTokenTestResults(allResults);
        
        res.json({ success: true, modelName, result: allResults[modelName] });
    } catch (error) {
        console.error('Error saving token test result:', error);
        res.status(500).json({
            error: 'Failed to save token test result',
            message: error.message
        });
    }
});

// API endpoint to get available token files
app.get('/api/token-files', async (req, res) => {
    try {
        const tokenFilesDir = path.join(__dirname, 'bigtokens', 'generated_tokens');
        const files = await fs.readdir(tokenFilesDir);
        
        // Parse token files and extract token counts
        const tokenFiles = files
            .filter(f => f.startsWith('tokens_') && f.endsWith('.txt'))
            .map(filename => {
                // Extract token count from filename: tokens_125,000.txt -> 125000
                const match = filename.match(/tokens_([\d,]+)\.txt/);
                if (match) {
                    const tokenCount = parseInt(match[1].replace(/,/g, ''));
                    return {
                        filename,
                        tokenCount,
                        path: `/api/token-files/${filename}`
                    };
                }
                return null;
            })
            .filter(f => f !== null)
            .sort((a, b) => a.tokenCount - b.tokenCount);

        res.json({ files: tokenFiles });
    } catch (error) {
        console.error('Error listing token files:', error);
        res.status(500).json({
            error: 'Failed to list token files',
            message: error.message
        });
    }
});

// API endpoint to serve a specific token file
app.get('/api/token-files/:filename', async (req, res) => {
    try {
        const { filename } = req.params;
        
        // Validate filename to prevent directory traversal
        if (!filename.match(/^tokens_[\d,]+\.txt$/)) {
            return res.status(400).json({ error: 'Invalid filename' });
        }

        const filePath = path.join(__dirname, 'bigtokens', 'generated_tokens', filename);
        const content = await fs.readFile(filePath, 'utf8');
        
        res.type('text/plain').send(content);
    } catch (error) {
        console.error('Error reading token file:', error);
        res.status(404).json({
            error: 'Token file not found',
            message: error.message
        });
    }
});

// API endpoint to test a model (proxy to Chutes AI)
app.post('/api/test-model', async (req, res) => {
    try {
        const { model, prompt, temperature = 0.7, max_tokens = 1000, testType } = req.body;

        if (!model) {
            return res.status(400).json({ error: 'Model ID is required' });
        }

        if (!prompt) {
            return res.status(400).json({ error: 'Prompt is required' });
        }

        if (!testType || !['latency', 'token'].includes(testType)) {
            return res.status(400).json({ error: 'testType must be either "latency" or "token"' });
        }

        console.log(`üß™ Testing model: ${model} (${testType} test)`);

        // Check rate limits
        let limitCheck;
        if (testType === 'token') {
            limitCheck = await checkTokenTestLimits(model);
        } else if (testType === 'latency') {
            limitCheck = await checkLatencyTestLimits();
        }

        if (!limitCheck.allowed) {
            console.log(`üö´ Rate limit exceeded for ${testType} test: ${limitCheck.reason}`);
            return res.status(429).json({
                error: 'Rate limit exceeded',
                message: limitCheck.reason
            });
        }

        const response = await fetch('https://llm.chutes.ai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${CHUTES_API_KEY}`
            },
            body: JSON.stringify({
                model,
                messages: [{ role: 'user', content: prompt }],
                temperature,
                max_tokens
            })
        });

        const responseData = await response.json();

        if (!response.ok) {
            console.error('API Error Response:', JSON.stringify(responseData, null, 2));
            throw new Error(responseData.error?.message || `HTTP ${response.status}`);
        }

        // Update rate limits on successful test
        await updateRateLimits(testType, testType === 'token' ? model : null);
        console.log(`‚úÖ ${testType} test successful for ${model}, rate limits updated`);

        res.json(responseData);
    } catch (error) {
        console.error('Error testing model:', error);
        res.status(500).json({
            error: 'Failed to test model',
            message: error.message
        });
    }
});

// Serve the main page
app.get('/', (req, res) => {
    const htmlFile = process.env.NODE_ENV === 'production' ? 'dist' : 'public';
    res.sendFile(path.join(__dirname, htmlFile, 'index.html'));
});

app.listen(PORT, () => {
    console.log(`‚úÖ Chutes Models Enhanced Server running on http://localhost:${PORT}`);
    console.log(`üì° Using Chutes API: ${CHUTES_BASE_URL}`);
    console.log(`üîë API Key configured: ${CHUTES_API_KEY ? 'Yes' : 'No'}`);
    console.log(`üíæ Cache enabled: ${CACHE_DURATION / 1000} seconds (${CACHE_DURATION_MINUTES} minutes)`);
    console.log(`üìÅ Cache directory: ${CACHE_DIR}`);
    console.log(`‚è±Ô∏è  API calls only happen when cache expires AND someone visits the site`);
});

</code>

vite.config.js:
<code>
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  root: 'public',
  base: './', // Use relative paths for assets
  build: {
    outDir: '../dist',
    emptyOutDir: true,
    rollupOptions: {
      input: {
        main: path.resolve(__dirname, 'public/index.html'),
        test: path.resolve(__dirname, 'public/test.html')
      }
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3888',
        changeOrigin: true
      }
    }
  }
});

</code>


public\og-image.png binary file skipped..


when i tried to run this on docker in a container on my server, which i have done before, now it immediately says failed all tests even with 10, isntant lists all of them as failed. something must have changed between last time i made a server